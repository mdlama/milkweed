---
title: "Mixed Model Selection"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  html_document:
    toc: true
---

Load necessary packages and data and perform initializations.

```{r, message=FALSE, warning=FALSE}
library(milkweed)
library(dplyr)
library(ggplot2)
library(lme4)
library(AICcmodavg)
requirePackages("DHARMa")

data("stemdata")
metadata <- stemdata
metadata$year <- factor(metadata$year)
metadata$transect <- factor(metadata$transect)

# https://stat.ethz.ch/pipermail/r-sig-mixed-models/2014q4/022870.html
glmerCtrl <- glmerControl(optimizer = c("bobyqa"), optCtrl = list(maxfun=50000))
lmerCtrl <- lmerControl(optimizer = c("bobyqa"), optCtrl = list(maxfun=50000))
```

# Model Selection
We will use the top-down approach for model selection discussed in Zuur et al 2009 (reccomended by Diggle et al 2002) starting with the full ("beyond optimal") model and refining the random effects first before moving on to the fixed effects.  

## Flowering

```{r}
metadata_usc <- metadata %>% filter(!is.na(h_apical),
                                    !is.na(herb_avg),
                                    !is.na(fec.flower))

metadata_sc <- metadata_usc %>% mutate_at(.vars = vars(h_apical, herb_avg),
                                          .funs = funs(as.numeric(scale(.)))) 

# Get scaling parameters (really just mean and sd)
h_apical_sc <- scale(metadata_usc$h_apical)
herb_avg_sc <- scale(metadata_usc$herb_avg)

metadata_sc %>% ggplot(aes(x = h_apical, 
                           y = fec.flower, 
                           color = year)) + 
                geom_jitter(height = 0.1, 
                            alpha = 0.3) +
                facet_wrap(~ site)
```

### Random Effects
Use nAGQ = 0 for quick approximations, but less exact form of parameter estimation.
```{r}
flower.reg.mdl1 <- glmer(fec.flower ~ h_apical*herb_avg + (h_apical*herb_avg|site/transect) + (h_apical*herb_avg|year), data=metadata_sc, nAGQ=0, family=binomial())
```

Let's try and simplify `site/transect` random effect first, but we'll keep `herb_avg` in as that is our main interest.
```{r}
flower.reg.mdl2=glmer(fec.flower ~ h_apical*herb_avg + (herb_avg|site/transect) + (h_apical*herb_avg|year), data=metadata_sc, nAGQ=0, family=binomial())

flower.reg.mdl3=glmer(fec.flower ~ h_apical*herb_avg + (1|site/transect) + (h_apical*herb_avg|year), data=metadata_sc, nAGQ=0, family=binomial())

aictab(list(flower.reg.mdl1, flower.reg.mdl2, flower.reg.mdl3), 
       modnames = c("mdl1", "mdl2", "mdl3"))
```

Models 2 and 3 are indistinguishable based on AIC, so we will move onto fixed effect selection keeping the more complicated random effect model, leading us to choose model 2. Let's move to `year` and compare all the different models.
```{r}
flower.reg.mdl4=glmer(fec.flower ~ h_apical*herb_avg + (herb_avg|site/transect) + (h_apical+herb_avg|year), data=metadata_sc, nAGQ=0, family=binomial())
flower.reg.mdl5=glmer(fec.flower ~ h_apical*herb_avg + (herb_avg|site/transect) + (h_apical|year), data=metadata_sc, nAGQ=0, family=binomial())
flower.reg.mdl6=glmer(fec.flower ~ h_apical*herb_avg + (herb_avg|site/transect) + (herb_avg|year), data=metadata_sc, nAGQ=0, family=binomial())
flower.reg.mdl7=glmer(fec.flower ~ h_apical*herb_avg + (herb_avg|site/transect) + (1|year), data=metadata_sc, nAGQ=0, family=binomial())

aictab(list(flower.reg.mdl2, flower.reg.mdl4, flower.reg.mdl5, flower.reg.mdl6, flower.reg.mdl7),
       modnames = c("mdl2","mdl4","mdl5","mdl6","mdl7"))

# AIC still indicates Models 2 easily

# nAGQ=1 uses Laplace approximation rather than quick approximation of before, for better estimation in the winning model.
flower.reg.winner=glmer(fec.flower ~ h_apical*herb_avg + (herb_avg|site/transect) + (h_apical*herb_avg|year), data=metadata_sc, nAGQ=1, family=binomial(), control=glmerCtrl)

summary(flower.reg.winner)
```

### Fixed Effects
Moving onto selection for fixed effects, first drop h_apical:herb_avg interaction term, since the p-value is the lowest non-stat. sig. then eliminate lowest term by term until only stat. sig. terms remain.
```{r}
flower.reg.mdl2a = glmer(fec.flower ~ h_apical + herb_avg + (herb_avg|site/transect)+(h_apical*herb_avg|year), data=metadata_sc, nAGQ=1, family=binomial(), control=glmerCtrl)
summary(flower.reg.mdl2a)

flower.reg.mdl2b = glmer(fec.flower ~ h_apical + herb_avg - 1 + (herb_avg|site/transect)+(h_apical*herb_avg|year), data=metadata_sc, nAGQ=1, family=binomial(), control=glmerCtrl)
summary(flower.reg.mdl2b)

flower.reg.mdl2c = glmer(fec.flower ~ h_apical - 1 + (herb_avg|site/transect)+(h_apical*herb_avg|year), data=metadata_sc, nAGQ=1, family=binomial(), control=glmerCtrl)
summary(flower.reg.mdl2c)

aictab(list(flower.reg.winner, flower.reg.mdl2a, flower.reg.mdl2b, flower.reg.mdl2c), 
       modnames = c("winner", "mdl2a", "mdl2b", "mdl2c"))
```

Looks like Model 2c and 2b are indistinguishable based on AICc. In the event of ties in the fixed effects, we have decided to use the model that includes herbivory, since we are interested to see if it is a predictor. If it is only a weak predictor after all, we will see that in sensitivity analysis of the IPM. Let's check p-values and create class to verify that unscaled version is correct.
```{r}
flower.reg.final <- flower.reg.mdl2b
summary(flower.reg.final)
```

### Model Validation and Diagnostics
Now some diagnostics (aka model validation). Creating the standard residual plots. Interpretting these plots is questionable for a non-linear model fit, so we will also imploy non-linear diagnostics next.
```{r}
par(mfrow=c(2,2))
plot(fitted(flower.reg.final), residuals(flower.reg.final, "deviance"), xlab="Fitted values", ylab="Deviance residuals")
plot(metadata_sc$h_apical, residuals(flower.reg.final, "deviance"), xlab="Apical height", ylab="Deviance residuals")
plot(metadata_sc$herb_avg, residuals(flower.reg.final, "deviance"), xlab="Herbivory average", ylab="Deviance residuals")
par(mfrow=c(1,1))
```

DHARMa package diagnostics for non-linear, hierarchical, mixed models. This simulates new data from the fitted model for the predictor variable combination of each observation. Then for each observation, calculates the empirical cumulative density function for the simulated data, which describes the expected spread for an observation at the respective point in predictor space, conditional on the fitted model. The residual is defined as the value of the empirical density function at the value of the observed data (DHARMa package vignette).
```{r}
flower.simulationOutput <- DHARMa::simulateResiduals(fittedModel = flower.reg.final, n=1000) #simulate data, n set to 1000 for high precision
```

```{r}
# DHARMa diagnostic plot, then plots of residuals against the predictor variables independently, we want flat horizontal lines at 0.25, 0.5, and 0.75 in a perfect world.
DHARMa::plotSimulatedResiduals(flower.simulationOutput)
DHARMa::plotResiduals(metadata_sc$h_apical, flower.simulationOutput$scaledResiduals)
DHARMa::plotResiduals(metadata_sc$herb_avg, flower.simulationOutput$scaledResiduals)
```

```{r}
# tests to see if the residuals fit the expected distribution
DHARMa::testUniformity(flower.simulationOutput)
```
Plots look great! Looks like the final model is a good fit. The Uniformity Test is probably failing since we have such a large sample size and it is not a particularly strong test. It does have a relatively large p-value compared to some other decent fits we've seen.

### Visualizations

Create model class
```{r}
scaled <- list(h_apical = h_apical_sc, herb_avg = herb_avg_sc)
flower.fit <- mwMod(list(mdl = flower.reg.final, vars = c("h_apical", "herb_avg"), scaled = scaled))
checkPars(flower.fit) # Check parameters
```

Scaled parameters across site:
```{r}
flower.fit$pars$scaled
```

Unscaled parameters across site:
```{r}
flower.fit$pars$unscaled
```

Let's plot full data.
```{r}
# Add points
flower.plot <- metadata_usc %>% 
  ggplot(aes(x = h_apical, 
             y = fec.flower, 
             color = site, 
             size = herb_avg)) +
  geom_jitter(width = 0, 
              height = 0.05,
              alpha = 0.4)

# Create plot data for prediction curves
plotdata <- metadata_usc %>% 
  group_by(site) %>% 
  summarize(mean_herb_avg = mean(herb_avg),
            min_h_apical = min(h_apical),
            max_h_apical = max(h_apical)) %>%
  add_row(site = "Bertha",
          mean_herb_avg = mean(metadata_usc$herb_avg, na.rm=T),
          min_h_apical = min(metadata_usc$h_apical, na.rm=T),
          max_h_apical = max(metadata_usc$h_apical, na.rm=T))

# Create prediction curves
N <- 100
suppressWarnings( # Hiding the follow warnings: (1) Unequal factor levels: coercing to character and (2) binding character and factor vector, coercing into character vector
  curves <- bind_rows(
    lapply(as.vector(plotdata$site), function(site) {
      i <- which(plotdata$site == site)
      data.frame(
        site = site,
        h_apical = seq(plotdata$min_h_apical[i], plotdata$max_h_apical[i], length.out = N),
        herb_avg = plotdata$mean_herb_avg[i],
        fec.flower = predict(
          flower.fit,
          type = site,
          newdata = data.frame(
            h_apical = seq(plotdata$min_h_apical[i], plotdata$max_h_apical[i], length.out = N),
            herb_avg = rep(plotdata$mean_herb_avg[i], N)
          )
        )
      )
    })
  )
)

flower.plot + geom_line(data = curves)
```

Now site-specific models.
```{r}
flower.plot <- metadata_usc %>% 
  ggplot(aes(x = h_apical, 
             y = fec.flower)) + 
  geom_jitter(height = 0.1, 
              alpha = 0.3) +
  facet_wrap(~ site)

flower.plot + 
  geom_line(data = curves %>% filter(site != "Bertha")) + 
  facet_wrap(~ site)
```

## Survival

```{r}
metadata_usc <- metadata %>% filter(!is.na(h_apical),
                                    !is.na(herb_avg),
                                    fec.flower == 1, # filtering out 0s because only the sexual pathway uses the survival function
                                    !is.na(surv))

metadata_sc <- metadata_usc %>% mutate_at(.vars = vars(h_apical, herb_avg),
                                          .funs = funs(as.numeric(scale(.))))

# Get scaling parameters (really just mean and sd)
h_apical_sc <- scale(metadata_usc$h_apical)
herb_avg_sc <- scale(metadata_usc$herb_avg)

metadata_sc %>% ggplot(aes(x = h_apical, 
                           y = surv, 
                           color = year)) + 
                geom_jitter(height = 0.1, 
                            alpha = 0.3) +
                facet_wrap(~ site)
```

### Random Effects
First fit full model. Using nAGQ = 0 for quick approximation (matches results with nAGQ = 1).
```{r}
surv.reg.full = glmer(surv ~ h_apical*herb_avg +  (h_apical*herb_avg|site/transect)+(h_apical*herb_avg|year), data=metadata_sc, nAGQ = 0, family=binomial())
summary(surv.reg.full)
```

First thing to go is interaction on site and transect, since it has very low variance and is contributing relatively little to the variation in the model.
```{r}
surv.reg.mdl1 = glmer(surv ~ h_apical*herb_avg +  (h_apical+herb_avg|site/transect)+(h_apical*herb_avg|year), data=metadata_sc, nAGQ=0, family=binomial())
summary(surv.reg.mdl1)
```


Interaction on year is also minimal in both, so it will be removed next.
```{r}
surv.reg.mdl2 = glmer(surv ~ h_apical*herb_avg +  (h_apical+herb_avg|site/transect)+(h_apical+herb_avg|year), data=metadata_sc, nAGQ=0, family=binomial())
summary(surv.reg.mdl2)
```

Dropping `herb_avg` in site/transect next.
```{r}
surv.reg.mdl3 = glmer(surv ~ h_apical*herb_avg +  (h_apical | site/transect) + (h_apical + herb_avg|year), data=metadata_sc, nAGQ=0, family=binomial())
summary(surv.reg.mdl3)
```

Now drop `herb_avg` on year.
```{r}
surv.reg.mdl4 = glmer(surv ~ h_apical*herb_avg +  (h_apical | site/transect) + (h_apical | year), data=metadata_sc, nAGQ=0, family=binomial())
summary(surv.reg.mdl4)
```

Now all that's left is to try combos of dropping `h_apical`.
```{r}
surv.reg.mdl5 = glmer(surv ~ h_apical*herb_avg +  (1|site/transect)+(h_apical|year), data=metadata_sc, nAGQ=0, family=binomial())
surv.reg.mdl6 = glmer(surv ~ h_apical*herb_avg +  (h_apical|site/transect)+(1|year), data=metadata_sc, nAGQ=0, family=binomial())
surv.reg.mdl7 = glmer(surv ~ h_apical*herb_avg +  (1|site/transect)+(1|year), data=metadata_sc, nAGQ=0, family=binomial())
```

AIC table.
```{r}
aictab(list(surv.reg.full, surv.reg.mdl1, surv.reg.mdl2, surv.reg.mdl3, surv.reg.mdl4, surv.reg.mdl5, surv.reg.mdl6, surv.reg.mdl7), modnames = c('surv.reg.full', 'surv.reg.mdl1', 'surv.reg.mdl2', 'surv.reg.mdl3', 'surv.reg.mdl4', 'surv.reg.mdl5', 'surv.reg.mdl6', 'surv.reg.mdl7'))
```

Winner: nearly indistinguishable AICc between Models 2 and 3.  Let's go with Model 2.
```{r}
surv.reg.winner = glmer(surv ~ h_apical*herb_avg +  (h_apical+herb_avg|site/transect)+(h_apical+herb_avg|year), data=metadata_sc, nAGQ=1, family=binomial(), control=glmerCtrl)
summary(surv.reg.winner)
```

### Fixed Effects
On to fixed effects, removing h_apical first.
```{r}
surv.reg.mdl1 = glmer(surv ~ herb_avg + h_apical:herb_avg + (h_apical+herb_avg|site/transect)+(h_apical+herb_avg|year), data=metadata_sc, family=binomial(), nAGQ=1, control=glmerCtrl)

surv.reg.mdl2 = glmer(surv ~ herb_avg + (h_apical+herb_avg|site/transect)+(h_apical+herb_avg|year), data=metadata_sc, family=binomial(), nAGQ=1, control=glmerCtrl)

surv.reg.mdl3 = glmer(surv ~ 1 + (h_apical+herb_avg|site/transect)+(h_apical+herb_avg|year), data=metadata_sc, family=binomial(), nAGQ=1, control=glmerCtrl)

sAICtab <- AIC(surv.reg.winner, surv.reg.mdl1, surv.reg.mdl2, surv.reg.mdl3)
sAICtab$dAIC <- min(sAICtab$AIC)-sAICtab$AIC
sAICtab

sBICtab <- BIC(surv.reg.winner, surv.reg.mdl1, surv.reg.mdl2, surv.reg.mdl3)
sBICtab$dBIC <- min(sBICtab$BIC)-sBICtab$BIC
sBICtab
```

```{r}
# mdl3 wins by large margin in BIC but close in AIC to mdl2 - since we're interested in herbivory, let's go with mdl2
surv.reg.final <- surv.reg.mdl2
summary(surv.reg.final)

# Create model class
scaled <- list(h_apical = h_apical_sc, herb_avg = herb_avg_sc)
surv.fit <- mwMod(list(mdl = surv.reg.final, vars = c("h_apical", "herb_avg"), scaled = scaled))
checkPars(surv.fit) # Check parameters
```

Winner:
```
surv ~ 1 + (log_herb_avg|site/transect) + (1|year)
```

Unscaling:
```{r, eval=FALSE}
par_intercept_sc <- coef(summary(surv.reg.final))["(Intercept)","Estimate"]

muha <- attributes(h_apical_sc)$'scaled:center'
sdha <- attributes(h_apical_sc)$'scaled:scale'
muhe <- attributes(log_herb_avg_sc)$'scaled:center'
sdhe <- attributes(log_herb_avg_sc)$'scaled:scale'

par_intercept_usc <- par_intercept_sc

pars <- c(par_intercept_usc, 0, 0, 0)
names(pars) <- c("(Intercept)", "h_apical", "log_herb_avg", "h_apical:log_herb_avg")
pars

par_sc <- cbind(coef(surv.reg.final)$site[,2], rep(0, 5), coef(surv.reg.final)$site[,1], rep(0, 5))
colnames(par_sc) <- c("(Intercept)", "h_apical", "log_herb_avg", "h_apical:log_herb_avg")
rownames(par_sc) <- rownames(coef(surv.reg.final)$site)
par_usc <- par_sc
for (i in 1:5) {
  par_usc[i,1] <- par_sc[i,1] - 1*par_sc[i,2]*(muha/sdha) - 1*par_sc[i,3]*(muhe/sdhe) + par_sc[i,4]*muha*muhe/(sdha*sdhe)
  par_usc[i,2] <- par_sc[i,2]/sdha - 1*par_sc[i,4]*muhe/(sdha*sdhe)
  par_usc[i,3] <- par_sc[i,3]/sdhe - 1*par_sc[i,4]*muha/(sdha*sdhe)
  par_usc[i,4] <- par_sc[i,4]/(sdha*sdhe)
}
par_usc
```

First, check to make sure unscaled parameters are correct.

```{r}
# Get parameters from model
pars <- getParameters(surv.reg.final, scaled = list(h_apical_sc = h_apical_sc, log_herb_avg_sc = log_herb_avg_sc))
pars_usc <- pars$unscaled

# Bertha
h_apical <- metadata_usc$h_apical
log_herb_avg <- metadata_usc$log_herb_avg
estresp <- 1/(1+exp(-1*(pars_usc['Bertha', '(Intercept)'] + pars_usc['Bertha', 'h_apical']*h_apical + pars_usc['Bertha', 'log_herb_avg']*log_herb_avg + pars_usc['Bertha', 'h_apical:log_herb_avg']*h_apical*log_herb_avg)))

fitresp <- predict(surv.reg.final, type="response", re.form=NA)

(error <- max(abs(estresp-fitresp)))

# Sites
sites <- rownames(pars_usc)[-1]
fitresp <- predict(surv.reg.final, type="response", re.form=~(log_herb_avg|site))
E <- rep(0, 5)
for (i in 1:length(sites)) {
  isite <- sites[i]
  h_apical <- (metadata_usc %>% filter(site == isite))$h_apical
  log_herb_avg <- (metadata_usc %>% filter(site == isite))$log_herb_avg
  estresp <- 1/(1+exp(-1*(pars_usc[isite,'(Intercept)'] + pars_usc[isite,'h_apical']*h_apical + pars_usc[isite,'log_herb_avg']*log_herb_avg + pars_usc[isite,'h_apical:log_herb_avg']*h_apical*log_herb_avg)))
  
  E[i] <- max(abs(estresp-fitresp[which(metadata_usc$site == isite)]))
}
max(E)
```

Now some diagnostics (aka model validation).

```{r}
par(mfrow=c(2,2))
plot(fitted(surv.reg.final), residuals(surv.reg.final, "deviance"), xlab="Fitted values", ylab="Deviance residuals")
plot(metadata_sc$h_apical, residuals(surv.reg.final, "deviance"), xlab="Apical height", ylab="Deviance residuals")
plot(metadata_sc$log_herb_avg, residuals(surv.reg.final, "deviance"), xlab="Log(Herbivory average)", ylab="Deviance residuals")
par(mfrow=c(1,1))
```

Let's plot full data, first on h_apical scale.

```{r}
plot(NULL, axes=T, xlim=c(0,160), ylim=c(-0.1,1.1), xlab="", ylab="")
xpts <- seq(min(metadata_usc$h_apical), max(metadata_usc$h_apical), length.out=100)
for (i in 1:5) {
  site <- rownames(par_usc)[i]
  points(metadata_usc[metadata_usc$site == site,]$h_apical, jitter(metadata_usc[metadata_usc$site == site,]$surv, factor=0.2), col=i, xlim=c(0,160))
  coeff <- par_usc[i,]
  meanha <- mean(metadata_usc[metadata_usc$site == site,]$log_herb_avg)
  ypred <- 1/(1+exp(-1*(coeff['(Intercept)'] + coeff['h_apical']*xpts + coeff['log_herb_avg']*meanha + coeff['h_apical:log_herb_avg']*xpts*meanha)))
  lines(xpts, ypred, col = i)
}
meanha <- mean(metadata_usc$log_herb_avg)
ypts = 1/(1+exp(-1*(pars['(Intercept)'] + pars['h_apical']*xpts + pars['log_herb_avg']*meanha + pars['h_apical:log_herb_avg']*xpts*meanha)))
lines(xpts, ypts, col="black", lwd=2, lty=2)
legend("bottomright", sort(unique(as.character(metadata_usc$site))), col=1:5, pch=1)
```

Now on log_herb_avg scale.

```{r}
plot(NULL, axes=T, xlim=c(-2.5,1.5), ylim=c(0.9,1.1), xlab="", ylab="")
xpts <- seq(min(metadata_usc$log_herb_avg), max(metadata_usc$log_herb_avg), length.out=100)
for (i in 1:5) {
  site <- rownames(par_usc)[i]
  points(metadata_usc[metadata_usc$site == site,]$log_herb_avg, jitter(metadata_usc[metadata_usc$site == site,]$surv, factor=0.2), col=i, xlim=c(-2.5,1.5))
  coeff <- par_usc[i,]
  meanha <- mean(metadata_usc[metadata_usc$site == site,]$h_apical)
  ypred <- 1/(1+exp(-1*(coeff['(Intercept)'] + coeff['h_apical']*meanha + coeff['log_herb_avg']*xpts + coeff['h_apical:log_herb_avg']*xpts*meanha)))
  lines(xpts, ypred, col = i)
}
meanha <- mean(metadata_usc$h_apical)
ypts = 1/(1+exp(-1*(pars['(Intercept)'] + pars['h_apical']*meanha + pars['log_herb_avg']*xpts + pars['h_apical:log_herb_avg']*xpts*meanha)))
lines(xpts, ypts, col="black", lwd=2, lty=2)
legend("bottomright", sort(unique(as.character(metadata_usc$site))), col=1:5, pch=1)
```

Now site-specific models.  First, h_apical.
```{r}
xpts <- seq(min(metadata_usc$h_apical), max(metadata_usc$h_apical), length.out=100)
xyplot(jitter(surv, factor=0.2) ~ h_apical|site, data=metadata_usc, para=par_usc, metadata=metadata_usc, xpts=xpts, panel = function(x,y,metadata,para,xpts) {
  panel.xyplot(x, y)
  site <- rownames(para)[packet.number()]
  coeff <- para[packet.number(),]
  meanhe <- mean(metadata[metadata$site == site,]$log_herb_avg)
  ypred <- 1/(1+exp(-1*(coeff['(Intercept)'] + coeff['h_apical']*xpts + coeff['log_herb_avg']*meanhe + coeff['h_apical:log_herb_avg']*xpts*meanhe)))
  panel.lines(xpts, ypred, col = "red")
})
```

Now site-specific models.  Now, log_herb_avg.
```{r}
xpts <- seq(min(metadata_usc$log_herb_avg), max(metadata_usc$log_herb_avg), length.out=100)
xyplot(jitter(surv, factor=0.2) ~ log_herb_avg|site, data=metadata_usc, para=par_usc, metadata=metadata_usc, xpts=xpts, panel = function(x,y,metadata,para,xpts) {
  panel.xyplot(x, y)
  site <- rownames(para)[packet.number()]
  coeff <- para[packet.number(),]
  meanha <- mean(metadata[metadata$site == site,]$h_apical)
  ypred <- 1/(1+exp(-1*(coeff['(Intercept)'] + coeff['h_apical']*meanha + coeff['log_herb_avg']*xpts + coeff['h_apical:log_herb_avg']*xpts*meanha)))
  panel.lines(xpts, ypred, col = "red")
})
```

## Growth

```{r}
# Transform data
metadata_usc <- metadata %>% filter(!is.na(h_apical),
                                    !is.na(h_apical.next),
                                    !is.na(herb_avg),
                                    fec.flower == 1,
                                    surv == 1) %>%
  mutate(log_herb_avg = log(0.01 + herb_avg))
                                        
metadata_sc <- metadata_usc %>% mutate_each(funs(as.numeric(scale(.))), 
                                            h_apical,
                                            h_apical.next, 
                                            log_herb_avg)

# Get scaling parameters (really just mean and sd)
h_apical_sc <- scale(metadata_usc$h_apical)
h_apical.next_sc <- scale(metadata_usc$h_apical.next)
log_herb_avg_sc <- scale(metadata_usc$log_herb_avg)

xyplot(h_apical.next ~ h_apical|site, data=metadata_sc, group=year, auto.key = TRUE)
```

As this is a bona-fide LME, we can do the method mentioned in Zuur.  First, model selection on random effects with REML.

```{r}
growth.reg.full=lmer(h_apical.next~h_apical*log_herb_avg + (h_apical*log_herb_avg|site/transect)+(h_apical*log_herb_avg|year),data=metadata_sc, REML=T)

growth.reg.mdl1a=lmer(h_apical.next~h_apical*log_herb_avg + (h_apical+log_herb_avg|site/transect)+(h_apical*log_herb_avg|year),data=metadata_sc, REML=T)

growth.reg.mdl1b=lmer(h_apical.next~h_apical*log_herb_avg + (h_apical*log_herb_avg|site/transect)+(h_apical+log_herb_avg|year),data=metadata_sc, REML=T)

growth.reg.mdl1c=lmer(h_apical.next~h_apical*log_herb_avg + (h_apical+log_herb_avg|site/transect)+(h_apical+log_herb_avg|year),data=metadata_sc, REML=T)

AIC(growth.reg.full, growth.reg.mdl1a, growth.reg.mdl1b, growth.reg.mdl1c)

growth.reg.mdl2=lmer(h_apical.next~h_apical*log_herb_avg + (h_apical+log_herb_avg|site/transect)+(h_apical|year),data=metadata_sc, REML=T)

growth.reg.mdl2a=lmer(h_apical.next~h_apical*log_herb_avg+(h_apical+log_herb_avg|site/transect)+(1|year),data=metadata_sc,REML=T)

growth.reg.mdl2b=lmer(h_apical.next~h_apical*log_herb_avg+(h_apical|site/transect)+(h_apical|year),data=metadata_sc,REML=T)

growth.reg.mdl2c=lmer(h_apical.next~h_apical*log_herb_avg+(log_herb_avg|site/transect)+(h_apical|year),data=metadata_sc,REML=T)

gAICtab <- AIC(growth.reg.full, growth.reg.mdl1a, growth.reg.mdl1b, growth.reg.mdl1c, growth.reg.mdl2, growth.reg.mdl2a, growth.reg.mdl2b, growth.reg.mdl2c)
gAICtab$dAIC <- min(gAICtab$AIC)-gAICtab$AIC
gAICtab

gBICtab <- BIC(growth.reg.full, growth.reg.mdl1a, growth.reg.mdl1b, growth.reg.mdl1c, growth.reg.mdl2, growth.reg.mdl2a, growth.reg.mdl2b, growth.reg.mdl2c)
gBICtab$dBIC <- min(gBICtab$BIC)-gBICtab$BIC
gBICtab

# Seems to be the best for random effects with AIC
# growth.reg.han2=lmer(h_apical.next~h_apical*log_herb_avg+(h_apical + log_herb_avg|site/transect)+(h_apical|year),data=metadata_sc,REML=T)

# Seems to be the best for fixed effects
# growth.reg.mdl4=lmer(h_apical.next~h_apical + (h_apical + herb_avg:munched|site/transect)+(h_apical|year),data=metadata_sc,REML=T)
```

Winner:
```
(h_apical + log_herb_avg|site/transect)+(h_apical|year)
```

Now fixed effects, with ML this time.

```{r}
growth.reg.fmdl1=lmer(h_apical.next ~ h_apical*log_herb_avg + (h_apical + log_herb_avg|site/transect)+(h_apical|year), data=metadata_sc, REML=F)

drop1(growth.reg.fmdl1, scope=c("h_apical", "log_herb_avg", "h_apical:log_herb_avg"))

# Looks like log_herb_avg goes
growth.reg.fmdl2=lmer(h_apical.next ~ h_apical + h_apical:log_herb_avg + (h_apical+log_herb_avg|site/transect)+(h_apical|year), data=metadata_sc, REML=F)

growth.reg.fmdl2a=lmer(h_apical.next ~ h_apical + (h_apical+log_herb_avg|site/transect)+(h_apical|year), data=metadata_sc, REML=F)

growth.reg.fmdl2b=lmer(h_apical.next ~ h_apical + h_apical:log_herb_avg - 1 + (h_apical+log_herb_avg|site/transect)+(h_apical|year), data=metadata_sc, REML=F)

growth.reg.fmdl2c=lmer(h_apical.next ~ h_apical:log_herb_avg + (h_apical+log_herb_avg|site/transect)+(h_apical|year), data=metadata_sc, REML=F)

# growth.reg.fmdl2b wins.  Let's try and drop one more...

growth.reg.fmdl3a=lmer(h_apical.next ~ h_apical - 1 + (h_apical+log_herb_avg|site/transect)+(h_apical|year), data=metadata_sc, REML=F)

growth.reg.fmdl3b=lmer(h_apical.next ~ h_apical:log_herb_avg - 1 + (h_apical+log_herb_avg|site/transect)+(h_apical|year), data=metadata_sc, REML=F)

# fmdl2b still seems the best.  Let's combine and reassess
gAICtab <- AIC(growth.reg.fmdl2, growth.reg.fmdl2a, growth.reg.fmdl2b, growth.reg.fmdl2c, growth.reg.fmdl3a, growth.reg.fmdl3b)
gAICtab$dAIC <- gAICtab$AIC-min(gAICtab$AIC)
gAICtab$wAIC <- exp(-0.5*gAICtab$dAIC)
gAICtab$wAIC <- gAICtab$wAIC/sum(gAICtab$wAIC)
(gAICtab <- gAICtab[order(gAICtab$AIC),])

gBICtab <- BIC(growth.reg.fmdl2, growth.reg.fmdl2a, growth.reg.fmdl2b, growth.reg.fmdl2c, growth.reg.fmdl3a, growth.reg.fmdl3b)
gBICtab$dBIC <- gBICtab$BIC-min(gBICtab$BIC)
gBICtab[order(gBICtab$BIC),]
```

Need to refit with REML.

```{r}
growth.reg.final=lmer(h_apical.next ~ h_apical + h_apical:log_herb_avg + (h_apical+log_herb_avg|site/transect) + (h_apical|year), data=metadata_sc, REML=T)
summary(growth.reg.final)

# Create model class
scaled <- list(h_apical = h_apical_sc, log_herb_avg = log_herb_avg_sc, h_apical.next = h_apical.next_sc)
growth.fit <- mwMod(list(mdl = growth.reg.final, vars = c("h_apical", "log_herb_avg"), scaled = scaled))
checkPars(growth.fit) # Check parameters
```

Winner:
```
h_apical.next ~ h_apical + h_apical:log_herb_avg + (h_apical + log_herb_avg|site)+(h_apical|year)
```

Let's get the unscaled parameters:
```{r, eval=FALSE}
par_intercept_sc <- coef(summary(growth.reg.final))["(Intercept)","Estimate"]
par_h_apical_sc <- coef(summary(growth.reg.final))["h_apical","Estimate"]
par_log_herb_avg_sc <- 0
par_interact_sc <- coef(summary(growth.reg.final))["h_apical:log_herb_avg","Estimate"]

muha <- attributes(h_apical_sc)$'scaled:center'
sdha <- attributes(h_apical_sc)$'scaled:scale'
muhan <- attributes(h_apical.next_sc)$'scaled:center'
sdhan <- attributes(h_apical.next_sc)$'scaled:scale'
muhe <- attributes(log_herb_avg_sc)$'scaled:center'
sdhe <- attributes(log_herb_avg_sc)$'scaled:scale'

par_intercept_usc <- muhan + sdhan*(par_intercept_sc - par_h_apical_sc*(muha/sdha) - par_log_herb_avg_sc*(muhe/sdhe) + par_interact_sc*muha*muhe/(sdha*sdhe))
par_h_apical_usc <- sdhan*(par_h_apical_sc/sdha - par_interact_sc*muhe/(sdha*sdhe))
par_log_herb_avg_usc <- sdhan*(par_log_herb_avg_sc/sdhe - par_interact_sc*muha/(sdha*sdhe))
par_interact_usc <- sdhan*(par_interact_sc/(sdha*sdhe))

pars <- c(par_intercept_usc, par_h_apical_usc, par_log_herb_avg_usc, par_interact_usc)
names(pars) <- c("(Intercept)", "h_apical", "log_herb_avg", "h_apical:log_herb_avg")
pars

par_sc <- coef(growth.reg.final)$site[c("(Intercept)","h_apical","log_herb_avg","h_apical:log_herb_avg")]
par_usc <- par_sc
for (i in 1:5) {
  par_usc[i,"(Intercept)"] <- muhan + sdhan*(par_sc[i,"(Intercept)"] - par_sc[i,"h_apical"]*(muha/sdha) - par_sc[i,"log_herb_avg"]*(muhe/sdhe) + par_sc[i,"h_apical:log_herb_avg"]*muha*muhe/(sdha*sdhe))
  par_usc[i,"h_apical"] <- sdhan*(par_sc[i,"h_apical"]/sdha - par_sc[i,"h_apical:log_herb_avg"]*muhe/(sdha*sdhe))
  par_usc[i,"log_herb_avg"] <- sdhan*(par_sc[i,"log_herb_avg"]/sdhe - par_sc[i,"h_apical:log_herb_avg"]*muha/(sdha*sdhe))
  par_usc[i,"h_apical:log_herb_avg"] <- sdhan*(par_sc[i,"h_apical:log_herb_avg"]/(sdha*sdhe))
}
par_usc
```

Let's check functions & compute standard deviation of residuals.
```{r}
# Get parameters from model
pars <- getParameters(growth.reg.final, scaled = list(h_apical_sc = h_apical_sc, log_herb_avg_sc = log_herb_avg_sc, h_apical.next_sc = h_apical.next_sc), growth=TRUE)
pars_usc <- pars$unscaled

# Bertha
h_apical <- metadata_usc$h_apical
log_herb_avg <- metadata_usc$log_herb_avg
estresp <- pars_usc['Bertha', '(Intercept)'] + pars_usc['Bertha', 'h_apical']*h_apical + pars_usc['Bertha', 'log_herb_avg']*log_herb_avg + pars_usc['Bertha', 'h_apical:log_herb_avg']*h_apical*log_herb_avg

muhan <- attributes(h_apical.next_sc)$'scaled:center'
sdhan <- attributes(h_apical.next_sc)$'scaled:scale'
fitresp <- muhan+sdhan*predict(growth.reg.final, type="response", re.form=NA)

(error <- max(abs(estresp-fitresp)))

# Sites
sites <- rownames(pars_usc)[-1]
fitresp <- muhan+sdhan*predict(growth.reg.final, type="response", re.form=~(h_apical+log_herb_avg|site))
E <- rep(0, 5)
for (i in 1:length(sites)) {
  isite <- sites[i]
  h_apical <- (metadata_usc %>% filter(site == isite))$h_apical
  log_herb_avg <- (metadata_usc %>% filter(site == isite))$log_herb_avg
  estresp <- pars_usc[isite,'(Intercept)'] + pars_usc[isite,'h_apical']*h_apical + pars_usc[isite,'log_herb_avg']*log_herb_avg + pars_usc[isite,'h_apical:log_herb_avg']*h_apical*log_herb_avg
  
  E[i] <- max(abs(estresp-fitresp[which(metadata_usc$site == isite)]))
}
max(E)
```

Now some diagnostics (aka model validation).

```{r}
par(mfrow=c(2,2))
plot(fitted(growth.reg.final), residuals(growth.reg.final, "deviance"), xlab="Fitted values", ylab="Deviance residuals")
plot(metadata_sc$h_apical, residuals(growth.reg.final, "deviance"), xlab="Apical height", ylab="Deviance residuals")
plot(metadata_sc$log_herb_avg, residuals(growth.reg.final, "deviance"), xlab="Log(Herbivory average)", ylab="Deviance residuals")
par(mfrow=c(1,1))
```

Let's plot full data.

```{r}
plot(NULL, axes=T, xlim=c(0,160), ylim=c(0, 200), xlab="", ylab="")
xpts <- seq(min(metadata_usc$h_apical), max(metadata_usc$h_apical), length.out=100)
for (i in 1:5) {
  site <- rownames(par_usc)[i]
  meanhe <- mean(metadata_usc[metadata_usc$site == site,]$log_herb_avg)
  points(metadata_usc[metadata_usc$site == site,]$h_apical, metadata_usc[metadata_usc$site == site,]$h_apical.next, col=i)
  ypred <- par_usc[site,'(Intercept)'] + par_usc[site,'h_apical']*xpts + par_usc[site,'log_herb_avg']*meanhe + par_usc[site,'h_apical:log_herb_avg']*xpts*meanhe
  lines(xpts, ypred, col = i)
}
meanhe <- mean(metadata_usc$log_herb_avg)
ypts = pars['(Intercept)'] + pars['h_apical']*xpts + pars['log_herb_avg']*meanhe + pars['h_apical:log_herb_avg']*xpts*meanhe
lines(xpts, ypts, col="black", lwd=2, lty=2)

legend("bottomright", sort(unique(as.character(metadata_usc$site))), col=1:5, pch=1)
```

Now site-specific models.
```{r}
xyplot(h_apical.next ~ h_apical|site, data=metadata_usc, para=par_usc, metadata=metadata_usc, xpts=xpts, panel = function(x,y,metadata,para,xpts) {
  panel.xyplot(x, y)
  isite <- rownames(para)[packet.number()]
  meanhe <- mean(metadata[metadata$site == isite,]$log_herb_avg)
  allha <- metadata[metadata$site == isite,]$h_apical
  allhe <- metadata[metadata$site == isite,]$log_herb_avg
  coeff <- para[packet.number(),]
  ymean <- coeff[,'(Intercept)'] + coeff[,'h_apical']*xpts + coeff[,'log_herb_avg']*meanhe + coeff[,'h_apical:log_herb_avg']*meanhe*xpts
  ypred <- coeff[,'(Intercept)'] + coeff[,'h_apical']*allha + coeff[,'log_herb_avg']*allhe + coeff[,'h_apical:log_herb_avg']*allha*allhe
  panel.lines(xpts, ymean, col = "red")
  panel.xyplot(allha, ypred, col='red')
})
```

Let's add year plots (just use predict function):
```{r, eval=FALSE}
xyplot(h_apical.next ~ h_apical|site, data=metadata_usc, para=ypar_usc, metadata=metadata_usc, xpts=xpts, fit=growth.reg.null, group=year, auto.key = TRUE, subscripts=FALSE, panel = function(x,y,groups=groups,subscripts=subscripts,metadata,para,xpts,fit) {
  panel.xyplot(x, y, groups=groups,subscripts=subscripts)
  site <- rownames(para)[packet.number()]
  cols <- c(4,6,3)
  for (i in 1:3) {
    meanhe <- mean(metadata[(metadata$site == site & metadata$year == dimnames(para)[[3]][i]),]$herb_avg)
    
    # First, explicit function
    coeff <- para[packet.number(),,i]
    ypred <- coeff['(Intercept)'] + coeff['h_apical']*xpts + coeff['herb_avg']*meanhe
    panel.lines(xpts, ypred, col = cols[i])
    
    # Now from fit
    # ypred <- predict(fit, newdata = data.frame(h_apical = (xpts-muha)/sdha, herb_avg = rep((meanhe-muhe)/sdhe, length(xpts)), site = site, year = dimnames(para)[[3]][i]))
    # panel.lines(xpts, ypred, col = cols[i], lty=2)
  }
})
```

Slopes are for some reason looking backwards!  Let's do model validation now.

```{r}
plot(growth.reg.final)
E <- resid(growth.reg.final)
hist(E, xlab = "Residuals", main = "")
plot(metadata_usc$h_apical, E, xlab = "Apical height", ylab = "Residuals")
plot(metadata_usc$log_herb_avg, E, xlab = "Avg. Herbivory Score", ylab = "Residuals")
```

## Pods

```{r}
metadata_usc <- metadata %>% filter(!is.na(h_apical),
                                    !is.na(h_apical.next),
                                    !is.na(herb_avg),
                                    fec.flower == 1,
                                    surv == 1,
                                    !is.na(N_pods),
                                    h_apical.next > 50,
                                    !(site == "YTB" & h_apical <= 50))

metadata_sc <- metadata_usc %>% mutate_each(funs(sc = as.numeric(scale(.))), h_apical, h_apical.next, log_herb_avg)

# Get scaling parameters (really just mean and sd)
h_apical_sc <- scale(metadata_usc$h_apical)
h_apical.next_sc <- scale(metadata_usc$h_apical.next)
log_herb_avg_sc <- scale(metadata_usc$log_herb_avg)

glmerCtrl <- glmerControl(optimizer = c("bobyqa"), optCtrl = list(maxfun=50000))

xyplot(N_pods ~ h_apical.next|site, data=metadata_sc, group=year, auto.key = TRUE)
```

First, do full model.

```{r}
pods.reg.full_sept = glmer(N_pods ~ h_apical.next*log_herb_avg + (h_apical.next*log_herb_avg|site/transect)+(h_apical.next*log_herb_avg|year), data=metadata_sc, nAGQ=1, family=poisson(), control=glmerCtrl)

pods.reg.full_june = glmer(N_pods ~ h_apical*log_herb_avg + (h_apical*log_herb_avg|site/transect)+(h_apical*log_herb_avg|year), data=metadata_sc, nAGQ=1, family=poisson(), control=glmerCtrl)

AIC(pods.reg.full_june, pods.reg.full_sept)
summary(pods.reg.full_sept)
```

We can try and drop h_apical.next:log_herb_avg in the random effect due to small variation.

```{r}
pods.reg.mdl1 = glmer(N_pods ~ h_apical.next*herb_avg + (h_apical.next*log_herb_avg|site/transect)+(h_apical.next+log_herb_avg|year), data=metadata_sc, nAGQ=1, family=poisson(), control=glmerCtrl)

pods.reg.mdl2 = glmer(N_pods ~ h_apical.next*herb_avg + (h_apical.next+log_herb_avg|site/transect)+(h_apical.next+log_herb_avg|year), data=metadata_sc, nAGQ=1, family=poisson(), control=glmerCtrl)

pods.reg.mdl3a = glmer(N_pods ~ h_apical.next*herb_avg + (h_apical.next|site/transect)+(h_apical.next+log_herb_avg|year), data=metadata_sc, nAGQ=1, family=poisson(), control=glmerCtrl)

pods.reg.mdl3b = glmer(N_pods ~ h_apical.next*herb_avg + (h_apical.next+log_herb_avg|site/transect)+(log_herb_avg|year), data=metadata_sc, nAGQ=1, family=poisson(), control=glmerCtrl)

pods.reg.mdl3c = glmer(N_pods ~ h_apical.next*herb_avg + (log_herb_avg|site/transect)+(h_apical.next+log_herb_avg|year), data=metadata_sc, nAGQ=1, family=poisson(), control=glmerCtrl)

AIC(pods.reg.full_sept, pods.reg.mdl1, pods.reg.mdl2, pods.reg.mdl3a, pods.reg.mdl3b, pods.reg.mdl3c)

summary(pods.reg.mdl2)
```

Winner:
```
(h_apical.next+log_herb_avg|site/transect)+(h_apical.next+log_herb_avg|year)
```

```{r}
pods.reg.fmdl1a = glmer(N_pods ~ h_apical.next + log_herb_avg + (h_apical.next+log_herb_avg|site/transect)+(h_apical.next+log_herb_avg|year), data=metadata_sc, nAGQ=1, family=poisson(), control=glmerCtrl)

pods.reg.fmdl1b = glmer(N_pods ~ h_apical.next + h_apical.next:log_herb_avg + (h_apical.next+log_herb_avg|site/transect)+(h_apical.next+log_herb_avg|year), data=metadata_sc, nAGQ=1, family=poisson(), control=glmerCtrl)

pods.reg.fmdl2a = glmer(N_pods ~ h_apical.next + log_herb_avg - 1 + (h_apical.next+log_herb_avg|site/transect)+(h_apical.next+log_herb_avg|year), data=metadata_sc, nAGQ=1, family=poisson(), control=glmerCtrl)

pods.reg.fmdl2b = glmer(N_pods ~ h_apical.next +  (h_apical.next+log_herb_avg|site/transect)+(h_apical.next+log_herb_avg|year), data=metadata_sc, nAGQ=1, family=poisson(), control=glmerCtrl)

pAICtab <- AIC(pods.reg.mdl2, pods.reg.fmdl1a, pods.reg.fmdl1b, pods.reg.fmdl2a, pods.reg.fmdl2b)
pAICtab$dAIC <- pAICtab$AIC-min(pAICtab$AIC)
pAICtab$wAIC <- exp(-0.5*pAICtab$dAIC)
pAICtab$wAIC <- pAICtab$wAIC/sum(pAICtab$wAIC)
(pAICtab <- pAICtab[order(pAICtab$AIC),])

pBICtab <- BIC(pods.reg.mdl2, pods.reg.fmdl1a, pods.reg.fmdl1b, pods.reg.fmdl2a, pods.reg.fmdl2b)
pBICtab$dBIC <- pBICtab$BIC-min(pBICtab$BIC)
pBICtab
```


```{r}
pods.reg.final <- pods.reg.fmdl2a
summary(pods.reg.final)

# Create model class
scaled <- list(h_apical = h_apical_sc, log_herb_avg = log_herb_avg_sc, h_apical.next = h_apical.next_sc)
pods.fit <- mwMod(list(mdl = pods.reg.final, vars = c("h_apical.next", "log_herb_avg"), scaled = scaled))
checkPars(pods.fit) # Check parameters
```

Winner:
```
h_apical.next + log_herb_avg - 1 + (h_apical.next+log_herb_avg|site/transect)+(h_apical.next+log_herb_avg|year)
```
### Check for overdispersion

From [GLMM Wiki](http://glmm.wikidot.com/faq), we grabbed and use the `overdisp_fun` function.

```{r, echo=F}
overdisp_fun <- function(model) {
  ## number of variance parameters in 
  ##   an n-by-n variance-covariance matrix
  vpars <- function(m) {
    nrow(m)*(nrow(m)+1)/2
  }
  model.df <- sum(sapply(VarCorr(model),vpars))+length(fixef(model))
  rdf <- nrow(model.frame(model))-model.df
  rp <- residuals(model,type="pearson")
  Pearson.chisq <- sum(rp^2)
  prat <- Pearson.chisq/rdf
  pval <- pchisq(Pearson.chisq, df=rdf, lower.tail=FALSE)
  c(chisq=Pearson.chisq,ratio=prat,rdf=rdf,p=pval)
}
```

```{r}
overdisp_fun(pods.reg.final)
```

We have a ratio of $1.0073585$ and a "large" $p$-value, so it looks like Poisson is a good fit!

Let's plot full data.

```{r, eval=FALSE}
plot(NULL, axes=T, xlim=c(50,160), ylim=c(0, 15), xlab="", ylab="")
h_apical.next <- attributes(pods.fit$scaled$h_apical.next)$'scaled:center'+attributes(pods.fit$scaled$h_apical.next)$'scaled:scale'*pods.fit$scaled$h_apical.next
log_herb_avg <- attributes(pods.fit$scaled$log_herb_avg)$'scaled:center'+attributes(pods.fit$scaled$log_herb_avg)$'scaled:scale'*pods.fit$scaled$log_herb_avg
xpts <- seq(min(h_apical.next), max(h_apical.next), length.out=100)
for (i in 1:5) {
  isite <- rownames(pods.fit$pars$unscaled)[i]
  I <- pods.fit$mdl@frame$site == isite
  points(h_apical.next[I], pods.fit$mdl@frame$N_pods[I], col=i)
}
for (i in 1:5) {
  isite <- rownames(pods.fit$pars$unscaled)[1+i]
  I <- which(pods.fit$mdl@frame$site == isite)
  meanhe <- mean(log_herb_avg[I])
  ypred <- predict(pods.fit, newdata = list(h_apical.next = xpts, log_herb_avg = meanhe), type=isite)
  lines(xpts, ypred, col = i, lwd=2)
}
meanhe <- mean(log_herb_avg)
ypred <- predict(pods.fit, newdata = list(h_apical.next = xpts, log_herb_avg = meanhe))
lines(xpts, ypred, col="black", lwd=4, lty=2)

legend("topleft", sort(unique(as.character(pods.fit$mdl@frame$site))), col=1:5, pch=1)
```

Now site-specific models.
```{r}
xyplot(N_pods ~ h_apical.next|site, data=metadata_usc, para=par_usc, metadata=metadata_usc, xpts=xpts, panel = function(x,y,metadata,para,xpts) {
  panel.xyplot(x, y)
  isite <- rownames(para)[packet.number()]
  meanhe <- mean(metadata[metadata$site == isite,]$log_herb_avg)
  allha <- metadata[metadata$site == isite,]$h_apical.next
  allhe <- metadata[metadata$site == isite,]$log_herb_avg
  coeff <- para[packet.number(),]
  ymean <- exp(coeff[,'(Intercept)'] + coeff[,'h_apical.next']*xpts + coeff[,'log_herb_avg']*meanhe + coeff[,'h_apical.next:log_herb_avg']*meanhe*xpts)
  ypred <- exp(coeff[,'(Intercept)'] + coeff[,'h_apical.next']*allha + coeff[,'log_herb_avg']*allhe + coeff[,'h_apical.next:log_herb_avg']*allha*allhe)
  panel.lines(xpts, ymean, col = "red")
  panel.xyplot(allha, ypred, col='red')
})
```

# References

 * [Model selection in GLMMs](http://stats.stackexchange.com/questions/74220/generalized-linear-mixed-models-model-selection)
 * [glmmLasso manual](https://cran.r-project.org/web/packages/glmmLasso/glmmLasso.pdf)
 * [Optimizing random effects in GLMMs](https://www.researchgate.net/post/How_can_I_optimize_the_random_effect_structure_in_a_GLMM)
 * [Paper discussing the need to use maximal random effects](http://www.ncbi.nlm.nih.gov/pmc/articles/PMC3881361/)
 * [Bayesian IPMs](http://onlinelibrary.wiley.com/doi/10.1890/15-1526.1/epdf)
 * [Discussion on how to check for overdispersion in GLMM from lme4](https://github.com/lme4/lme4/issues/220)
 * [Heteroscedasticity in lme4](http://r-sig-mixed-models.r-project.narkive.com/qfqOsMAN/r-sig-me-lme4-heteroscedasticity)
 * [Difference between lme4 and nlme](http://stats.stackexchange.com/questions/5344/how-to-choose-nlme-or-lme4-r-library-for-mixed-effects-models)
 * [Specifying multiple random effects in nlme](http://stats.stackexchange.com/questions/58669/specifying-multiple-separate-random-effects-in-lme)
 * [Variance-covariance structure for random effects in glmer](http://stats.stackexchange.com/questions/86958/variance-covariance-structure-for-random-effects-in-glmer)
 * [Displaying model fits in lattice plots](http://lattice.r-forge.r-project.org/Vignettes/src/lattice-tricks/regression-lines.pdf)
 * [Extracting slopes for cases from a mixed effects model (lme4)](http://stats.stackexchange.com/questions/122009/extracting-slopes-for-cases-from-a-mixed-effects-model-lme4)
 * [Taking control of qualitative colors in lattice](http://www.stat.ubc.ca/~jenny/STAT545A/block16_colorsLatticeQualitative.html)
 
# Appendix

## glmmLasso

The next bit is stuff from the function `glmmLasso`, which is another package that does variable selection for GLMMs.  Keeping it for reference (took me a bit to figure out how to use the damn thing).

```{r, eval=FALSE}
gL1 <- glmmLasso(fec.flower ~ h_apical + herb_avg + h_apical:herb_avg, rnd = list(site=~1, year=~1+h_apical), lambda=10, data=metadata_sc, family=binomial(link=logit))
gL2 <- glmmLasso(fec.flower ~ h_apical + herb_avg + h_apical:herb_avg, rnd = list(site=~1+herb_avg, year=~1+h_apical), lambda=10, data=metadata_sc, family=binomial(link=logit))
```

To use it properly, `lambda` needs to be optimized.  Type ` demo("glmmLasso-soccer")` in R to see how this is done (draft code is in the file `glmmFit.R`).

## Growth (individual sites)

Let's look at BLD1 first:

```{r, eval=F}
metaBLD1 <- metadata %>% filter(site == "BLD1",
                                !is.na(h_apical),
                                !is.na(h_apical.next),
                                !is.na(herb_avg),
                                fec.flower == 1,
                                surv == 1)
xyplot(h_apical.next ~ h_apical, data=metaBLD1, group = year, auto.key = TRUE)

growth.reg.null=lmer(h_apical.next~h_apical*herb_avg+(1|year),data=metaBLD1, REML=T)

growth.reg.height=lmer(h_apical.next~h_apical*herb_avg+(h_apical|year),data=metaBLD1, REML=T)

growth.reg.herb=lmer(h_apical.next~h_apical*herb_avg+(herb_avg|year),data=metaBLD1, REML=T)

AIC(growth.reg.null, growth.reg.height, growth.reg.herb)

growth.mdl1.BLD1 <- lm(h_apical.next ~ h_apical*herb_avg, data=metaBLD1)
growth.mdlnoi.BLD1 <- lm(h_apical.next ~ h_apical+herb_avg, data=metaBLD1)
growth.mdlnohe.BLD1 <- lm(h_apical.next ~ h_apical+h_apical:herb_avg, data=metaBLD1)
growth.mdl0.BLD1 <- lm(h_apical.next ~ h_apical, data=metaBLD1)

AIC(growth.mdl1.BLD1, growth.mdlnoi.BLD1, growth.mdlnohe.BLD1, growth.mdl0.BLD1)

par(mfrow=c(2,2))
plot(growth.mdlnohe.BLD1)
par(mfrow=c(1,1))
```

Now BLD2:

```{r, eval=F}
metaBLD2 <- metadata %>% filter(site == "BLD2",
                                fec.flower == 1,
                                !is.na(h_apical),
                                !is.na(h_apical.next),
                                !is.na(herb_avg))
growth.mdl1.BLD2 <- lm(h_apical.next ~ h_apical*herb_avg, data=metaBLD2)
growth.mdlnoi.BLD2 <- lm(h_apical.next ~ h_apical+herb_avg, data=metaBLD2)
growth.mdlnohe.BLD2 <- lm(h_apical.next ~ h_apical+h_apical:herb_avg, data=metaBLD2)
growth.mdl0.BLD2 <- lm(h_apical.next ~ h_apical, data=metaBLD2)

AIC(growth.mdl1.BLD2, growth.mdlnoi.BLD2, growth.mdlnohe.BLD2, growth.mdl0.BLD2)

par(mfrow=c(2,2))
plot(growth.mdlnohe.BLD2)
par(mfrow=c(1,1))
```

Now PWR:

```{r, eval=F}
metaPWR <- metadata %>% filter(site == "PWR",
                                fec.flower == 1,
                                !is.na(h_apical),
                                !is.na(h_apical.next),
                                !is.na(herb_avg))
growth.mdl1.PWR <- lm(h_apical.next ~ h_apical*herb_avg, data=metaPWR)
growth.mdlnoi.PWR <- lm(h_apical.next ~ h_apical+herb_avg, data=metaPWR)
growth.mdlnohe.PWR <- lm(h_apical.next ~ h_apical+h_apical:herb_avg, data=metaPWR)
growth.mdl0.PWR <- lm(h_apical.next ~ h_apical, data=metaPWR)

AIC(growth.mdl1.PWR, growth.mdlnoi.PWR, growth.mdlnohe.PWR, growth.mdl0.PWR)

par(mfrow=c(2,2))
plot(growth.mdlnohe.PWR)
par(mfrow=c(1,1))
```

Now SKY:

```{r, eval=F}
metaSKY <- metadata %>% filter(site == "SKY",
                                fec.flower == 1,
                                !is.na(h_apical),
                                !is.na(h_apical.next),
                                !is.na(herb_avg))
growth.mdl1.SKY <- lm(h_apical.next ~ h_apical*herb_avg, data=metaSKY)
growth.mdlnoi.SKY <- lm(h_apical.next ~ h_apical+herb_avg, data=metaSKY)
growth.mdlnohe.SKY <- lm(h_apical.next ~ h_apical+h_apical:herb_avg, data=metaSKY)
growth.mdl0.SKY <- lm(h_apical.next ~ h_apical, data=metaSKY)

AIC(growth.mdl1.SKY, growth.mdlnoi.SKY, growth.mdlnohe.SKY, growth.mdl0.SKY)

par(mfrow=c(2,2))
plot(growth.mdl1.SKY)
par(mfrow=c(1,1))
```

Now YTB:

```{r, eval=F}
metaYTB <- metadata %>% filter(site == "YTB",
                               fec.flower == 1,
                               surv == 1,
                               h_apical > 50,
                               h_apical.next > 50,
                               !is.na(h_apical),
                               !is.na(h_apical.next),
                               !is.na(herb_avg))

xyplot(h_apical.next ~ h_apical, data=metaYTB, group = year, auto.key = TRUE)

growth.reg.null=lmer(h_apical.next~h_apical*herb_avg+(1|year),data=metaYTB, REML=T)

growth.reg.height=lmer(h_apical.next~h_apical*herb_avg+(h_apical|year),data=metaYTB, REML=T)

AIC(growth.reg.null, growth.reg.height)

growth.mdl1.YTB <- lm(h_apical.next ~ h_apical*herb_avg, data=metaYTB)
growth.mdlnoi.YTB <- lm(h_apical.next ~ h_apical+herb_avg, data=metaYTB)
growth.mdlnohe.YTB <- lm(h_apical.next ~ h_apical+h_apical:herb_avg, data=metaYTB)
growth.mdl0.YTB <- lm(h_apical.next ~ h_apical, data=metaYTB)

AIC(growth.mdl1.YTB, growth.mdlnoi.YTB, growth.mdlnohe.YTB, growth.mdl0.YTB)

par(mfrow=c(2,2))
plot(growth.mdl1.YTB)
par(mfrow=c(1,1))
```
