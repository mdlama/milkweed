---
title: "Mixed Model Selection"
author: "M. Drew LaMar"
date: "May 9, 2016"
output: 
  html_document:
    toc: true
---

Load necessary packages.

```{r, message=FALSE, warning=FALSE}
library(dplyr)
library(lme4) #lme4 package contains function lmer() to analyze linear mixed effects regressions. 
library(lattice) #lattice package contains function dotplot() to visualize confidence intervals of parameter estimates in each site
```

```{r}
# Create class
# foo <- structure(list(mdl, scaled, vars, pars), class = "vrate")
predict.vrate <- function(obj, newdata, type="Bertha") {
  pars <- obj$pars$unscaled
  linpart <- pars[type,"(Intercept)"] + pars[type,obj$vars[1]]*newdata[[obj$vars[1]]] + pars[type,obj$vars[2]]*newdata[[obj$vars[2]]] + pars[type,paste0(obj$vars[1],":",obj$vars[2])]*newdata[[obj$vars[1]]]*newdata[[obj$vars[2]]]
  if (class(obj$mdl) == "glmerMod") {
    predict.vrate <- obj$mdl@resp$family$linkinv(linpart)
  } else {
    predict.vrate <- linpart
  }
}
```

Load the aggregate data set & necessary packages
```{r}
metadata=tbl_df(read.csv("../../data/stemdata.csv"))
metadata$year <- factor(metadata$year)
metadata$transect <- factor(metadata$transect)
```

# Model Selection

## Flowering

```{r}
metadata_usc <- metadata %>% filter(!is.na(h_apical),
                                    !is.na(h_apical.next),
                                    !is.na(herb_avg),
                                    !is.na(fec.flower),
                                    !is.na(surv))

metadata_sc <- metadata_usc %>% mutate_each(funs(sc = as.numeric(scale(.))), h_apical, log_herb_avg)

# Get scaling parameters (really just mean and sd)
h_apical_sc <- scale(metadata_usc$h_apical)
log_herb_avg_sc <- scale(metadata_usc$log_herb_avg)

metadata_sc %>% ggplot(aes(x = h_apical, 
                           y = fec.flower, 
                           color = year)) + 
                geom_jitter(height = 0.1, alpha = 0.3) +
                facet_wrap(~ site)
```

First fit full model.

```{r}
# Use nAGQ = 0 for quick approximations
flower.reg.mdl1=glmer(fec.flower ~ h_apical*log_herb_avg + (h_apical*log_herb_avg|site/transect) + (h_apical*log_herb_avg|year), data=metadata_sc, nAGQ=0, family=binomial())

flower.reg.mdl2=glmer(fec.flower ~ h_apical*log_herb_avg + (log_herb_avg|site/transect) + (h_apical*log_herb_avg|year), data=metadata_sc, nAGQ=0, family=binomial())

flower.reg.mdl3=glmer(fec.flower ~ h_apical*log_herb_avg + (1|site/transect) + (h_apical*log_herb_avg|year), data=metadata_sc, nAGQ=0, family=binomial())

flower.reg.mdl4=glmer(fec.flower ~ h_apical*log_herb_avg + (1|site/transect) + (h_apical+log_herb_avg|year), data=metadata_sc, nAGQ=0, family=binomial())

flower.reg.mdl5=glmer(fec.flower ~ h_apical*log_herb_avg + (1|site/transect) + (h_apical|year), data=metadata_sc, nAGQ=0, family=binomial())

AIC(flower.reg.mdl1, flower.reg.mdl2, flower.reg.mdl3, flower.reg.mdl4, flower.reg.mdl5)
BIC(flower.reg.mdl1, flower.reg.mdl2, flower.reg.mdl3, flower.reg.mdl4, flower.reg.mdl5)

# BIC says to choose Model #4 (AIC wants full model!!!)
# https://stat.ethz.ch/pipermail/r-sig-mixed-models/2014q4/022870.html
glmerCtrl <- glmerControl(optimizer = c("bobyqa"), optCtrl = list(maxfun=50000))

flower.reg.winner=glmer(fec.flower ~ h_apical*log_herb_avg + (1|site/transect) + (h_apical+log_herb_avg|year), data=metadata_sc, nAGQ=1, family=binomial(), control=glmerCtrl)

# The following model gives the lowest AIC and BIC, but doesn't converge.  Will try an alternate (see ?modular)
# flower.reg.mdl4=glmer(fec.flower ~ h_apical*log_herb_avg + (1|site/transect) + (h_apical+log_herb_avg|year), data=metadata_sc, nAGQ=1, family=binomial())
# glmod <- glFormula(fec.flower ~ h_apical*log_herb_avg + (log_herb_avg|site/transect) + (h_apical*log_herb_avg|year), data=metadata_sc, family = binomial)
# devfun <- do.call(mkGlmerDevfun, glmod)
# opt <- optimizeGlmer(devfun)
# devfun <- updateGlmerDevfun(devfun, glmod$reTrms, nAGQ=1)
# opt <- optimizeGlmer(devfun, stage=2, nAGQ=1)
# flower.reg.mdl4=mkMerMod(environment(devfun), opt, glmod$reTrms, fr = glmod$fr)

summary(flower.reg.winner)
```

For fixed effects, first drop log_herb_avg.

```{r}
flower.reg.mdl1 = glmer(fec.flower ~ h_apical + h_apical:log_herb_avg + (1|site/transect)+(h_apical+log_herb_avg|year), data=metadata_sc, nAGQ=1, family=binomial(), control=glmerCtrl)

# Let's try and drop the intercept
flower.reg.mdl2 = glmer(fec.flower ~ h_apical + h_apical:log_herb_avg - 1 + (1|site/transect)+(h_apical+log_herb_avg|year), data=metadata_sc, nAGQ=1, family=binomial(), control=glmerCtrl)

fAICtab <- AIC(flower.reg.winner, flower.reg.mdl1, flower.reg.mdl2)
fAICtab$dAIC <- min(fAICtab$AIC)-fAICtab$AIC
fAICtab

fBICtab <- BIC(flower.reg.winner, flower.reg.mdl1, flower.reg.mdl2)
fBICtab$dBIC <- min(fBICtab$BIC)-fBICtab$BIC
fBICtab
```

Let's check P-values:
```{r}
flower.reg.final <- flower.reg.mdl2
summary(flower.reg.final)

# Create model class
scaled <- list(h_apical = h_apical_sc, log_herb_avg = log_herb_avg_sc)
flower.fit <- mwMod(list(mdl = flower.reg.final, vars = c("h_apical", "log_herb_avg"), scaled = scaled))
checkPars(flower.fit) # Check parameters
```

Winner (scaled):
```
fec.flower ~ h_apical + h_apical:log_herb_avg - 1 + (1|site/transect) + (h_apical+log_herb_avg|year)
```

Winner (unscaled):
```
fec.flower ~ h_apical*log_herb_avg + (1|site/transect) + (h_apical+log_herb_avg|year)
```

```{r}
getParameters <- function(mdl, scaled, h_apical = "h_apical", growth=FALSE) {
  pars <- list(scaled=NA, unscaled=NA)
  pars$scaled <- matrix(rep(0,6*4), byrow=TRUE, nrow=6)
  colnames(pars$scaled) <- c("(Intercept)", h_apical, "log_herb_avg", paste0(h_apical, ":log_herb_avg"))
  rownames(pars$scaled) <- c("Bertha", "BLD1", "BLD2", "PWR", "SKY", "YTB")
  
  # Assign values for Bertha
  assignme <- rownames(coef(summary(mdl)))
  for (i in 1:length(assignme)) {
    pars$scaled["Bertha", assignme[i]] <- coef(summary(mdl))[assignme[i], "Estimate"]
  }
  
  # Assign values for sites
  for (i in 1:ncol(coef(mdl)$site)) {
    varexp <- colnames(coef(mdl)$site)[i]
    pars$scaled[2:6,varexp] <- coef(mdl)$site[,varexp]
  }
  
  muhan <- 0
  sdhan <- 1
  if (growth) {
    muhan <- attributes(scaled$h_apical.next_sc)$'scaled:center'
    sdhan <- attributes(scaled$h_apical.next_sc)$'scaled:scale'

    pars$sd <- rep(0,6)
    names(pars$sd) <- c("Bertha", "BLD1", "BLD2", "PWR", "SKY", "YTB")
    pars$sd['Bertha'] <- sdhan*sd(mdl@frame$h_apical.next - predict(mdl, type="response", re.form=NA))
    pars$sd[2:6] <- sdhan*sd(mdl@frame$h_apical.next - predict(mdl, type="response", re.form=~(h_apical+log_herb_avg|site)))
  }
  muha <- attributes(scaled$h_apical_sc)$'scaled:center'
  sdha <- attributes(scaled$h_apical_sc)$'scaled:scale'
  muhe <- attributes(scaled$log_herb_avg_sc)$'scaled:center'
  sdhe <- attributes(scaled$log_herb_avg_sc)$'scaled:scale'
  
  # Calculate unscaled parameters
  pars$unscaled <- pars$scaled %*% diag(c(sdhan, sdhan/sdha, sdhan/sdhe, sdhan/(sdha*sdhe))) %*%
                          cbind(c(1, -1*muha, -1*muhe, muha*muhe),
                                c(0,       1,       0,   -1*muhe),
                                c(0,       0,       1,   -1*muha),
                                c(0,       0,       0,         1)) +
                          cbind(rep(muhan, 6), matrix(rep(0, 18), nrow=6))
  colnames(pars$unscaled) <- c("(Intercept)", h_apical, "log_herb_avg", paste0(h_apical, ":log_herb_avg"))
  
  getParameters <- pars
}
```

```{r, eval=FALSE}
par_h_apical_sc <- coef(summary(flower.reg.final))["h_apical","Estimate"]
par_interact_sc <- coef(summary(flower.reg.final))["h_apical:log_herb_avg","Estimate"]

muha <- attributes(h_apical_sc)$'scaled:center'
sdha <- attributes(h_apical_sc)$'scaled:scale'
muhe <- attributes(log_herb_avg_sc)$'scaled:center'
sdhe <- attributes(log_herb_avg_sc)$'scaled:scale'

par_intercept_usc <- -1*par_h_apical_sc*(muha/sdha) + 1*par_interact_sc*muha*muhe/(sdha*sdhe)
par_h_apical_usc <- par_h_apical_sc/sdha - 1*par_interact_sc*muhe/(sdha*sdhe)
par_herb_avg_usc <- -1*par_interact_sc*muha/(sdha*sdhe)
par_interact_usc <- par_interact_sc/(sdha*sdhe)

pars <- c(par_intercept_usc, par_h_apical_usc, par_herb_avg_usc, par_interact_usc)
names(pars) <- c("(Intercept)", "h_apical", "log_herb_avg", "h_apical:log_herb_avg")
pars

par_sc <- coef(flower.reg.final)$site[c(1,3,2,4)]
par_usc <- par_sc
for (i in 1:5) {
  par_usc[i,1] <- par_sc[i,1] - 1*par_sc[i,2]*(muha/sdha) - 1*par_sc[i,3]*(muhe/sdhe) + par_sc[i,4]*muha*muhe/(sdha*sdhe)
  par_usc[i,2] <- par_sc[i,2]/sdha - 1*par_sc[i,4]*muhe/(sdha*sdhe)
  par_usc[i,3] <- par_sc[i,3]/sdhe - 1*par_sc[i,4]*muha/(sdha*sdhe)
  par_usc[i,4] <- par_sc[i,4]/(sdha*sdhe)
}
par_usc
```

Let's get the unscaled parameters and check to make sure unscaled parameters are correct.
```{r}
# Get parameters from model
pars <- getParameters(flower.reg.final, scaled = list(h_apical_sc = h_apical_sc, log_herb_avg_sc = log_herb_avg_sc))
pars_usc <- pars$unscaled

# Bertha
h_apical <- metadata_usc$h_apical
log_herb_avg <- metadata_usc$log_herb_avg
estresp <- 1/(1+exp(-1*(pars_usc['Bertha','(Intercept)'] + pars_usc['Bertha', 'h_apical']*h_apical + pars_usc['Bertha', 'log_herb_avg']*log_herb_avg + pars_usc['Bertha', 'h_apical:log_herb_avg']*h_apical*log_herb_avg)))

fitresp <- predict(flower.reg.final, type="response", re.form=NA)

(error <- max(abs(estresp-fitresp)))

# Sites
sites <- rownames(pars_usc)[-1]
fitresp <- predict(flower.reg.final, type="response", re.form=~(1|site))
E <- rep(0, 5)
for (i in 1:length(sites)) {
  isite <- sites[i]
  h_apical <- (metadata_usc %>% filter(site == isite))$h_apical
  log_herb_avg <- (metadata_usc %>% filter(site == isite))$log_herb_avg
  estresp <- 1/(1+exp(-1*(pars_usc[isite,'(Intercept)'] + pars_usc[isite,'h_apical']*h_apical + pars_usc[isite,'log_herb_avg']*log_herb_avg + pars_usc[isite,'h_apical:log_herb_avg']*h_apical*log_herb_avg)))
  
  E[i] <- max(abs(estresp-fitresp[which(metadata_usc$site == isite)]))
}
max(E)
```

Now some diagnostics (aka model validation).

```{r}
par(mfrow=c(2,2))
plot(fitted(flower.reg.final), residuals(flower.reg.final, "deviance"), xlab="Fitted values", ylab="Deviance residuals")
plot(metadata_sc$h_apical, residuals(flower.reg.final, "deviance"), xlab="Apical height", ylab="Deviance residuals")
plot(metadata_sc$log_herb_avg, residuals(flower.reg.final, "deviance"), xlab="Log(Herbivory average)", ylab="Deviance residuals")
par(mfrow=c(1,1))
```

Let's plot full data.

```{r}
plot(NULL, axes=T, xlim=c(0,160), ylim=c(-0.1,1.1), xlab="", ylab="")
for (i in 1:5) {
  site <- row.names(par_usc[i,])
  I <- order(metadata_usc[metadata_usc$site == site,]$h_apical)
  h_apical <- metadata_usc[metadata_usc$site == site,]$h_apical[I]
  log_herb_avg <- mean(metadata_usc[metadata_usc$site == site,]$log_herb_avg[I])
  xpts <- h_apical
  ypts <- metadata_usc[metadata_usc$site == site,]$fec.flower[I]
  site <- row.names(par_usc[i,])
  points(xpts, jitter(ypts, factor=0.2), col=i, xlim=c(0,160))
  coeff <- par_usc[i,]
  ypred <- 1/(1+exp(-1*(as.numeric(coeff['(Intercept)']) + as.numeric(coeff['h_apical'])*h_apical + as.numeric(coeff['log_herb_avg'])*log_herb_avg + as.numeric(coeff['h_apical:log_herb_avg'])*h_apical*log_herb_avg)))
  lines(xpts, ypred, col = i)
}
meanha <- mean(metadata_usc$log_herb_avg)
ypts = 1/(1+exp(-1*(pars['(Intercept)'] + pars['h_apical']*xpts + pars['log_herb_avg']*meanha + pars['h_apical:log_herb_avg']*xpts*meanha)))
lines(xpts, ypts, col="black", lwd=2, lty=2)
legend("bottomright", sort(unique(as.character(metadata_usc$site))), col=1:5, pch=1)
```

```{r, eval=FALSE}
plot(NULL, axes=T, xlim=c(0,160), ylim=c(-0.1,1.1), xlab="", ylab="")
xpts <- seq(min(metadata_usc$h_apical), max(metadata_usc$h_apical), length.out=100)
for (i in 1:5) {
  site <- row.names(par_usc[i,])
  points(metadata_usc[metadata_usc$site == site,]$h_apical, jitter(metadata_usc[metadata_usc$site == site,]$fec.flower, factor=0.2), col=i, xlim=c(0,160))
  meanha <- mean(metadata_usc[metadata_usc$site == site,]$log_herb_avg)
  coeff <- par_usc[i,]
  ypred <- with(coeff, 1/(1+exp(-1*(`(Intercept)` + `h_apical`*xpts + `log_herb_avg`*meanha + `h_apical:log_herb_avg`*xpts*meanha))))
  lines(xpts, ypred, col = i)
}
meanha <- mean(metadata_usc$log_herb_avg)
ypts = 1/(1+exp(-1*(pars['(Intercept)'] + pars['h_apical']*xpts + pars['log_herb_avg']*meanha + pars['h_apical:log_herb_avg']*xpts*meanha)))
lines(xpts, ypts, col="black", lwd=2, lty=2)
legend("bottomright", sort(unique(as.character(metadata_usc$site))), col=1:5, pch=1)
```

Now site-specific models.
```{r}
xyplot(jitter(fec.flower, factor=0.2) ~ h_apical|site, data=metadata_usc, para=par_usc, metadata=metadata_usc, xpts=xpts, panel = function(x,y,metadata,para,xpts) {
  panel.xyplot(x, y)
  site <- row.names(para[packet.number(),])
  meanha <- mean(metadata[metadata$site == site,]$log_herb_avg)
  coeff <- para[packet.number(),]
  ypred <- with(coeff, 1/(1+exp(-1*(`(Intercept)` + `h_apical`*xpts + `log_herb_avg`*meanha + `h_apical:log_herb_avg`*xpts*meanha))))
  panel.lines(xpts, ypred, col = "red")
})
```

## Survival

```{r}
metadata_usc <- metadata %>% filter(!is.na(h_apical),
                                    !is.na(h_apical.next),
                                    !is.na(herb_avg),
                                    fec.flower == 1,
                                    !is.na(surv),
                                    h_apical.next > 50,
                                    !(site == "YTB" & h_apical <= 50))

metadata_sc <- metadata_usc %>% mutate_each(funs(sc = as.numeric(scale(.))), h_apical, log_herb_avg)

# Get scaling parameters (really just mean and sd)
h_apical_sc <- scale(metadata_usc$h_apical)
log_herb_avg_sc <- scale(metadata_usc$log_herb_avg)

xyplot(jitter(surv, factor=0.2) ~ h_apical|site, data=metadata_sc, group=year, auto.key = TRUE)
```

First fit full model.

```{r}
# nAGQ = 0 for quick approximation (matches results with nAGQ = 1)
surv.reg.full = glmer(surv ~ h_apical*log_herb_avg +  (h_apical*log_herb_avg|site/transect)+(h_apical*log_herb_avg|year), data=metadata_sc, nAGQ = 0, family=binomial())

summary(surv.reg.full)
```

First thing to go is interaction on site and transect.

```{r}
surv.reg.mdl1 = glmer(surv ~ h_apical*log_herb_avg +  (h_apical+log_herb_avg|site/transect)+(h_apical*log_herb_avg|year), data=metadata_sc, nAGQ=0, family=binomial())

# h_apical is minimal in both
surv.reg.mdl2 = glmer(surv ~ h_apical*log_herb_avg +  (log_herb_avg|site/transect)+(log_herb_avg+h_apical:log_herb_avg|year), data=metadata_sc, nAGQ=0, family=binomial())

# Dropping interaction term on year
surv.reg.mdl3 = glmer(surv ~ h_apical*log_herb_avg +  (log_herb_avg|site/transect)+(log_herb_avg|year), data=metadata_sc, nAGQ=0, family=binomial())

# Let's try combo of dropping log_herb_avg
surv.reg.mdl4a = glmer(surv ~ h_apical*log_herb_avg +  (1|site/transect)+(log_herb_avg|year), data=metadata_sc, nAGQ=0, family=binomial())

surv.reg.mdl4b = glmer(surv ~ h_apical*log_herb_avg +  (log_herb_avg|site/transect)+(1|year), data=metadata_sc, nAGQ=0, family=binomial())

surv.reg.mdl4c = glmer(surv ~ h_apical*log_herb_avg +  (1|site/transect)+(1|year), data=metadata_sc, nAGQ=0, family=binomial())

sAICtab <- AIC(surv.reg.full, surv.reg.mdl1, surv.reg.mdl2, surv.reg.mdl3, surv.reg.mdl4a, surv.reg.mdl4b, surv.reg.mdl4c)
sAICtab$dAIC <- min(sAICtab$AIC)-sAICtab$AIC
sAICtab

sBICtab <- BIC(surv.reg.full, surv.reg.mdl1, surv.reg.mdl2, surv.reg.mdl3, surv.reg.mdl4a, surv.reg.mdl4b, surv.reg.mdl4c)
sBICtab$dBIC <- min(sBICtab$BIC)-sBICtab$BIC
sBICtab

# Winner: AIC gives mdl4b, BIC mdl4c - let's go with mdl4b
surv.reg.winner = glmer(surv ~ h_apical*log_herb_avg +  (log_herb_avg|site/transect)+(1|year), data=metadata_sc, family=binomial(), nAGQ=1, control=glmerCtrl)

summary(surv.reg.winner)
```

That's better.  On to fixed effects.

```{r}
surv.reg.mdl1 = glmer(surv ~ log_herb_avg + h_apical:log_herb_avg + (log_herb_avg|site/transect)+(1|year), data=metadata_sc, family=binomial(), nAGQ=1, control=glmerCtrl)

surv.reg.mdl2 = glmer(surv ~ log_herb_avg + (log_herb_avg|site/transect)+(1|year), data=metadata_sc, family=binomial(), nAGQ=1, control=glmerCtrl)

surv.reg.mdl3 = glmer(surv ~ 1 + (log_herb_avg|site/transect)+(1|year), data=metadata_sc, family=binomial(), nAGQ=1, control=glmerCtrl)

sAICtab <- AIC(surv.reg.winner, surv.reg.mdl1, surv.reg.mdl2, surv.reg.mdl3)
sAICtab$dAIC <- min(sAICtab$AIC)-sAICtab$AIC
sAICtab

sBICtab <- BIC(surv.reg.winner, surv.reg.mdl1, surv.reg.mdl2, surv.reg.mdl3)
sBICtab$dBIC <- min(sBICtab$BIC)-sBICtab$BIC
sBICtab
```

```{r}
# mdl3 wins by large margin in AIC and BIC
surv.reg.final <- surv.reg.mdl3
summary(surv.reg.final)

# Create model class
scaled <- list(h_apical = h_apical_sc, log_herb_avg = log_herb_avg_sc)
surv.fit <- mwMod(list(mdl = surv.reg.final, vars = c("h_apical", "log_herb_avg"), scaled = scaled))
checkPars(surv.fit) # Check parameters
```

Winner:
```
surv ~ 1 + (log_herb_avg|site/transect) + (1|year)
```

Unscaling:
```{r, eval=FALSE}
par_intercept_sc <- coef(summary(surv.reg.final))["(Intercept)","Estimate"]

muha <- attributes(h_apical_sc)$'scaled:center'
sdha <- attributes(h_apical_sc)$'scaled:scale'
muhe <- attributes(log_herb_avg_sc)$'scaled:center'
sdhe <- attributes(log_herb_avg_sc)$'scaled:scale'

par_intercept_usc <- par_intercept_sc

pars <- c(par_intercept_usc, 0, 0, 0)
names(pars) <- c("(Intercept)", "h_apical", "log_herb_avg", "h_apical:log_herb_avg")
pars

par_sc <- cbind(coef(surv.reg.final)$site[,2], rep(0, 5), coef(surv.reg.final)$site[,1], rep(0, 5))
colnames(par_sc) <- c("(Intercept)", "h_apical", "log_herb_avg", "h_apical:log_herb_avg")
rownames(par_sc) <- rownames(coef(surv.reg.final)$site)
par_usc <- par_sc
for (i in 1:5) {
  par_usc[i,1] <- par_sc[i,1] - 1*par_sc[i,2]*(muha/sdha) - 1*par_sc[i,3]*(muhe/sdhe) + par_sc[i,4]*muha*muhe/(sdha*sdhe)
  par_usc[i,2] <- par_sc[i,2]/sdha - 1*par_sc[i,4]*muhe/(sdha*sdhe)
  par_usc[i,3] <- par_sc[i,3]/sdhe - 1*par_sc[i,4]*muha/(sdha*sdhe)
  par_usc[i,4] <- par_sc[i,4]/(sdha*sdhe)
}
par_usc
```

First, check to make sure unscaled parameters are correct.

```{r}
# Get parameters from model
pars <- getParameters(surv.reg.final, scaled = list(h_apical_sc = h_apical_sc, log_herb_avg_sc = log_herb_avg_sc))
pars_usc <- pars$unscaled

# Bertha
h_apical <- metadata_usc$h_apical
log_herb_avg <- metadata_usc$log_herb_avg
estresp <- 1/(1+exp(-1*(pars_usc['Bertha', '(Intercept)'] + pars_usc['Bertha', 'h_apical']*h_apical + pars_usc['Bertha', 'log_herb_avg']*log_herb_avg + pars_usc['Bertha', 'h_apical:log_herb_avg']*h_apical*log_herb_avg)))

fitresp <- predict(surv.reg.final, type="response", re.form=NA)

(error <- max(abs(estresp-fitresp)))

# Sites
sites <- rownames(pars_usc)[-1]
fitresp <- predict(surv.reg.final, type="response", re.form=~(log_herb_avg|site))
E <- rep(0, 5)
for (i in 1:length(sites)) {
  isite <- sites[i]
  h_apical <- (metadata_usc %>% filter(site == isite))$h_apical
  log_herb_avg <- (metadata_usc %>% filter(site == isite))$log_herb_avg
  estresp <- 1/(1+exp(-1*(pars_usc[isite,'(Intercept)'] + pars_usc[isite,'h_apical']*h_apical + pars_usc[isite,'log_herb_avg']*log_herb_avg + pars_usc[isite,'h_apical:log_herb_avg']*h_apical*log_herb_avg)))
  
  E[i] <- max(abs(estresp-fitresp[which(metadata_usc$site == isite)]))
}
max(E)
```

Now some diagnostics (aka model validation).

```{r}
par(mfrow=c(2,2))
plot(fitted(surv.reg.final), residuals(surv.reg.final, "deviance"), xlab="Fitted values", ylab="Deviance residuals")
plot(metadata_sc$h_apical, residuals(surv.reg.final, "deviance"), xlab="Apical height", ylab="Deviance residuals")
plot(metadata_sc$log_herb_avg, residuals(surv.reg.final, "deviance"), xlab="Log(Herbivory average)", ylab="Deviance residuals")
par(mfrow=c(1,1))
```

Let's plot full data, first on h_apical scale.

```{r}
plot(NULL, axes=T, xlim=c(0,160), ylim=c(-0.1,1.1), xlab="", ylab="")
xpts <- seq(min(metadata_usc$h_apical), max(metadata_usc$h_apical), length.out=100)
for (i in 1:5) {
  site <- rownames(par_usc)[i]
  points(metadata_usc[metadata_usc$site == site,]$h_apical, jitter(metadata_usc[metadata_usc$site == site,]$surv, factor=0.2), col=i, xlim=c(0,160))
  coeff <- par_usc[i,]
  meanha <- mean(metadata_usc[metadata_usc$site == site,]$log_herb_avg)
  ypred <- 1/(1+exp(-1*(coeff['(Intercept)'] + coeff['h_apical']*xpts + coeff['log_herb_avg']*meanha + coeff['h_apical:log_herb_avg']*xpts*meanha)))
  lines(xpts, ypred, col = i)
}
meanha <- mean(metadata_usc$log_herb_avg)
ypts = 1/(1+exp(-1*(pars['(Intercept)'] + pars['h_apical']*xpts + pars['log_herb_avg']*meanha + pars['h_apical:log_herb_avg']*xpts*meanha)))
lines(xpts, ypts, col="black", lwd=2, lty=2)
legend("bottomright", sort(unique(as.character(metadata_usc$site))), col=1:5, pch=1)
```

Now on log_herb_avg scale.

```{r}
plot(NULL, axes=T, xlim=c(-2.5,1.5), ylim=c(0.9,1.1), xlab="", ylab="")
xpts <- seq(min(metadata_usc$log_herb_avg), max(metadata_usc$log_herb_avg), length.out=100)
for (i in 1:5) {
  site <- rownames(par_usc)[i]
  points(metadata_usc[metadata_usc$site == site,]$log_herb_avg, jitter(metadata_usc[metadata_usc$site == site,]$surv, factor=0.2), col=i, xlim=c(-2.5,1.5))
  coeff <- par_usc[i,]
  meanha <- mean(metadata_usc[metadata_usc$site == site,]$h_apical)
  ypred <- 1/(1+exp(-1*(coeff['(Intercept)'] + coeff['h_apical']*meanha + coeff['log_herb_avg']*xpts + coeff['h_apical:log_herb_avg']*xpts*meanha)))
  lines(xpts, ypred, col = i)
}
meanha <- mean(metadata_usc$h_apical)
ypts = 1/(1+exp(-1*(pars['(Intercept)'] + pars['h_apical']*meanha + pars['log_herb_avg']*xpts + pars['h_apical:log_herb_avg']*xpts*meanha)))
lines(xpts, ypts, col="black", lwd=2, lty=2)
legend("bottomright", sort(unique(as.character(metadata_usc$site))), col=1:5, pch=1)
```

Now site-specific models.  First, h_apical.
```{r}
xpts <- seq(min(metadata_usc$h_apical), max(metadata_usc$h_apical), length.out=100)
xyplot(jitter(surv, factor=0.2) ~ h_apical|site, data=metadata_usc, para=par_usc, metadata=metadata_usc, xpts=xpts, panel = function(x,y,metadata,para,xpts) {
  panel.xyplot(x, y)
  site <- rownames(para)[packet.number()]
  coeff <- para[packet.number(),]
  meanhe <- mean(metadata[metadata$site == site,]$log_herb_avg)
  ypred <- 1/(1+exp(-1*(coeff['(Intercept)'] + coeff['h_apical']*xpts + coeff['log_herb_avg']*meanhe + coeff['h_apical:log_herb_avg']*xpts*meanhe)))
  panel.lines(xpts, ypred, col = "red")
})
```

Now site-specific models.  Now, log_herb_avg.
```{r}
xpts <- seq(min(metadata_usc$log_herb_avg), max(metadata_usc$log_herb_avg), length.out=100)
xyplot(jitter(surv, factor=0.2) ~ log_herb_avg|site, data=metadata_usc, para=par_usc, metadata=metadata_usc, xpts=xpts, panel = function(x,y,metadata,para,xpts) {
  panel.xyplot(x, y)
  site <- rownames(para)[packet.number()]
  coeff <- para[packet.number(),]
  meanha <- mean(metadata[metadata$site == site,]$h_apical)
  ypred <- 1/(1+exp(-1*(coeff['(Intercept)'] + coeff['h_apical']*meanha + coeff['log_herb_avg']*xpts + coeff['h_apical:log_herb_avg']*xpts*meanha)))
  panel.lines(xpts, ypred, col = "red")
})
```

## Growth

```{r}
# Transform data
metadata_usc <- metadata %>% filter(!is.na(h_apical),
                                    !is.na(h_apical.next),
                                    !is.na(herb_avg),
                                    fec.flower == 1,
                                    surv == 1,
                                    h_apical.next > 50,
                                    !(site == "YTB" & h_apical <= 50))

metadata_sc <- metadata_usc %>% mutate_each(funs(sc = as.numeric(scale(.))), h_apical, h_apical.next, log_herb_avg)

# Get scaling parameters (really just mean and sd)
h_apical_sc <- scale(metadata_usc$h_apical)
h_apical.next_sc <- scale(metadata_usc$h_apical.next)
log_herb_avg_sc <- scale(metadata_usc$log_herb_avg)

xyplot(h_apical.next ~ h_apical|site, data=metadata_sc, group=year, auto.key = TRUE)
```

As this is a bona-fide LME, we can do the method mentioned in Zuur.  First, model selection on random effects with REML.

```{r}
growth.reg.full=lmer(h_apical.next~h_apical*log_herb_avg + (h_apical*log_herb_avg|site/transect)+(h_apical*log_herb_avg|year),data=metadata_sc, REML=T)

growth.reg.mdl1a=lmer(h_apical.next~h_apical*log_herb_avg + (h_apical+log_herb_avg|site/transect)+(h_apical*log_herb_avg|year),data=metadata_sc, REML=T)

growth.reg.mdl1b=lmer(h_apical.next~h_apical*log_herb_avg + (h_apical*log_herb_avg|site/transect)+(h_apical+log_herb_avg|year),data=metadata_sc, REML=T)

growth.reg.mdl1c=lmer(h_apical.next~h_apical*log_herb_avg + (h_apical+log_herb_avg|site/transect)+(h_apical+log_herb_avg|year),data=metadata_sc, REML=T)

AIC(growth.reg.full, growth.reg.mdl1a, growth.reg.mdl1b, growth.reg.mdl1c)

growth.reg.mdl2=lmer(h_apical.next~h_apical*log_herb_avg + (h_apical+log_herb_avg|site/transect)+(h_apical|year),data=metadata_sc, REML=T)

growth.reg.mdl2a=lmer(h_apical.next~h_apical*log_herb_avg+(h_apical+log_herb_avg|site/transect)+(1|year),data=metadata_sc,REML=T)

growth.reg.mdl2b=lmer(h_apical.next~h_apical*log_herb_avg+(h_apical|site/transect)+(h_apical|year),data=metadata_sc,REML=T)

growth.reg.mdl2c=lmer(h_apical.next~h_apical*log_herb_avg+(log_herb_avg|site/transect)+(h_apical|year),data=metadata_sc,REML=T)

gAICtab <- AIC(growth.reg.full, growth.reg.mdl1a, growth.reg.mdl1b, growth.reg.mdl1c, growth.reg.mdl2, growth.reg.mdl2a, growth.reg.mdl2b, growth.reg.mdl2c)
gAICtab$dAIC <- min(gAICtab$AIC)-gAICtab$AIC
gAICtab

gBICtab <- BIC(growth.reg.full, growth.reg.mdl1a, growth.reg.mdl1b, growth.reg.mdl1c, growth.reg.mdl2, growth.reg.mdl2a, growth.reg.mdl2b, growth.reg.mdl2c)
gBICtab$dBIC <- min(gBICtab$BIC)-gBICtab$BIC
gBICtab

# Seems to be the best for random effects with AIC
# growth.reg.han2=lmer(h_apical.next~h_apical*log_herb_avg+(h_apical + log_herb_avg|site/transect)+(h_apical|year),data=metadata_sc,REML=T)

# Seems to be the best for fixed effects
# growth.reg.mdl4=lmer(h_apical.next~h_apical + (h_apical + herb_avg:munched|site/transect)+(h_apical|year),data=metadata_sc,REML=T)
```

Winner:
```
(h_apical + log_herb_avg|site/transect)+(h_apical|year)
```

Now fixed effects, with ML this time.

```{r}
growth.reg.fmdl1=lmer(h_apical.next ~ h_apical*log_herb_avg + (h_apical + log_herb_avg|site/transect)+(h_apical|year), data=metadata_sc, REML=F)

drop1(growth.reg.fmdl1, scope=c("h_apical", "log_herb_avg", "h_apical:log_herb_avg"))

# Looks like log_herb_avg goes
growth.reg.fmdl2=lmer(h_apical.next ~ h_apical + h_apical:log_herb_avg + (h_apical+log_herb_avg|site/transect)+(h_apical|year), data=metadata_sc, REML=F)

growth.reg.fmdl2a=lmer(h_apical.next ~ h_apical + (h_apical+log_herb_avg|site/transect)+(h_apical|year), data=metadata_sc, REML=F)

growth.reg.fmdl2b=lmer(h_apical.next ~ h_apical + h_apical:log_herb_avg - 1 + (h_apical+log_herb_avg|site/transect)+(h_apical|year), data=metadata_sc, REML=F)

growth.reg.fmdl2c=lmer(h_apical.next ~ h_apical:log_herb_avg + (h_apical+log_herb_avg|site/transect)+(h_apical|year), data=metadata_sc, REML=F)

# growth.reg.fmdl2b wins.  Let's try and drop one more...

growth.reg.fmdl3a=lmer(h_apical.next ~ h_apical - 1 + (h_apical+log_herb_avg|site/transect)+(h_apical|year), data=metadata_sc, REML=F)

growth.reg.fmdl3b=lmer(h_apical.next ~ h_apical:log_herb_avg - 1 + (h_apical+log_herb_avg|site/transect)+(h_apical|year), data=metadata_sc, REML=F)

# fmdl2b still seems the best.  Let's combine and reassess
gAICtab <- AIC(growth.reg.fmdl2, growth.reg.fmdl2a, growth.reg.fmdl2b, growth.reg.fmdl2c, growth.reg.fmdl3a, growth.reg.fmdl3b)
gAICtab$dAIC <- gAICtab$AIC-min(gAICtab$AIC)
gAICtab$wAIC <- exp(-0.5*gAICtab$dAIC)
gAICtab$wAIC <- gAICtab$wAIC/sum(gAICtab$wAIC)
(gAICtab <- gAICtab[order(gAICtab$AIC),])

gBICtab <- BIC(growth.reg.fmdl2, growth.reg.fmdl2a, growth.reg.fmdl2b, growth.reg.fmdl2c, growth.reg.fmdl3a, growth.reg.fmdl3b)
gBICtab$dBIC <- gBICtab$BIC-min(gBICtab$BIC)
gBICtab[order(gBICtab$BIC),]
```

Need to refit with REML.

```{r}
growth.reg.final=lmer(h_apical.next ~ h_apical + h_apical:log_herb_avg + (h_apical+log_herb_avg|site/transect)+(h_apical|year), data=metadata_sc, REML=T)
summary(growth.reg.final)

# Create model class
scaled <- list(h_apical = h_apical_sc, log_herb_avg = log_herb_avg_sc, h_apical.next = h_apical.next_sc)
growth.fit <- mwMod(list(mdl = growth.reg.final, vars = c("h_apical", "log_herb_avg"), scaled = scaled))
checkPars(growth.fit) # Check parameters
```

Winner:
```
h_apical.next ~ h_apical + h_apical:log_herb_avg + (h_apical + log_herb_avg|site)+(h_apical|year)
```

Let's get the unscaled parameters:
```{r, eval=FALSE}
par_intercept_sc <- coef(summary(growth.reg.final))["(Intercept)","Estimate"]
par_h_apical_sc <- coef(summary(growth.reg.final))["h_apical","Estimate"]
par_log_herb_avg_sc <- 0
par_interact_sc <- coef(summary(growth.reg.final))["h_apical:log_herb_avg","Estimate"]

muha <- attributes(h_apical_sc)$'scaled:center'
sdha <- attributes(h_apical_sc)$'scaled:scale'
muhan <- attributes(h_apical.next_sc)$'scaled:center'
sdhan <- attributes(h_apical.next_sc)$'scaled:scale'
muhe <- attributes(log_herb_avg_sc)$'scaled:center'
sdhe <- attributes(log_herb_avg_sc)$'scaled:scale'

par_intercept_usc <- muhan + sdhan*(par_intercept_sc - par_h_apical_sc*(muha/sdha) - par_log_herb_avg_sc*(muhe/sdhe) + par_interact_sc*muha*muhe/(sdha*sdhe))
par_h_apical_usc <- sdhan*(par_h_apical_sc/sdha - par_interact_sc*muhe/(sdha*sdhe))
par_log_herb_avg_usc <- sdhan*(par_log_herb_avg_sc/sdhe - par_interact_sc*muha/(sdha*sdhe))
par_interact_usc <- sdhan*(par_interact_sc/(sdha*sdhe))

pars <- c(par_intercept_usc, par_h_apical_usc, par_log_herb_avg_usc, par_interact_usc)
names(pars) <- c("(Intercept)", "h_apical", "log_herb_avg", "h_apical:log_herb_avg")
pars

par_sc <- coef(growth.reg.final)$site[c("(Intercept)","h_apical","log_herb_avg","h_apical:log_herb_avg")]
par_usc <- par_sc
for (i in 1:5) {
  par_usc[i,"(Intercept)"] <- muhan + sdhan*(par_sc[i,"(Intercept)"] - par_sc[i,"h_apical"]*(muha/sdha) - par_sc[i,"log_herb_avg"]*(muhe/sdhe) + par_sc[i,"h_apical:log_herb_avg"]*muha*muhe/(sdha*sdhe))
  par_usc[i,"h_apical"] <- sdhan*(par_sc[i,"h_apical"]/sdha - par_sc[i,"h_apical:log_herb_avg"]*muhe/(sdha*sdhe))
  par_usc[i,"log_herb_avg"] <- sdhan*(par_sc[i,"log_herb_avg"]/sdhe - par_sc[i,"h_apical:log_herb_avg"]*muha/(sdha*sdhe))
  par_usc[i,"h_apical:log_herb_avg"] <- sdhan*(par_sc[i,"h_apical:log_herb_avg"]/(sdha*sdhe))
}
par_usc
```

Let's check functions & compute standard deviation of residuals.
```{r}
# Get parameters from model
pars <- getParameters(growth.reg.final, scaled = list(h_apical_sc = h_apical_sc, log_herb_avg_sc = log_herb_avg_sc, h_apical.next_sc = h_apical.next_sc), growth=TRUE)
pars_usc <- pars$unscaled

# Bertha
h_apical <- metadata_usc$h_apical
log_herb_avg <- metadata_usc$log_herb_avg
estresp <- pars_usc['Bertha', '(Intercept)'] + pars_usc['Bertha', 'h_apical']*h_apical + pars_usc['Bertha', 'log_herb_avg']*log_herb_avg + pars_usc['Bertha', 'h_apical:log_herb_avg']*h_apical*log_herb_avg

muhan <- attributes(h_apical.next_sc)$'scaled:center'
sdhan <- attributes(h_apical.next_sc)$'scaled:scale'
fitresp <- muhan+sdhan*predict(growth.reg.final, type="response", re.form=NA)

(error <- max(abs(estresp-fitresp)))

# Sites
sites <- rownames(pars_usc)[-1]
fitresp <- muhan+sdhan*predict(growth.reg.final, type="response", re.form=~(h_apical+log_herb_avg|site))
E <- rep(0, 5)
for (i in 1:length(sites)) {
  isite <- sites[i]
  h_apical <- (metadata_usc %>% filter(site == isite))$h_apical
  log_herb_avg <- (metadata_usc %>% filter(site == isite))$log_herb_avg
  estresp <- pars_usc[isite,'(Intercept)'] + pars_usc[isite,'h_apical']*h_apical + pars_usc[isite,'log_herb_avg']*log_herb_avg + pars_usc[isite,'h_apical:log_herb_avg']*h_apical*log_herb_avg
  
  E[i] <- max(abs(estresp-fitresp[which(metadata_usc$site == isite)]))
}
max(E)
```

Now some diagnostics (aka model validation).

```{r}
par(mfrow=c(2,2))
plot(fitted(growth.reg.final), residuals(growth.reg.final, "deviance"), xlab="Fitted values", ylab="Deviance residuals")
plot(metadata_sc$h_apical, residuals(growth.reg.final, "deviance"), xlab="Apical height", ylab="Deviance residuals")
plot(metadata_sc$log_herb_avg, residuals(growth.reg.final, "deviance"), xlab="Log(Herbivory average)", ylab="Deviance residuals")
par(mfrow=c(1,1))
```

Let's plot full data.

```{r}
plot(NULL, axes=T, xlim=c(0,160), ylim=c(0, 200), xlab="", ylab="")
xpts <- seq(min(metadata_usc$h_apical), max(metadata_usc$h_apical), length.out=100)
for (i in 1:5) {
  site <- rownames(par_usc)[i]
  meanhe <- mean(metadata_usc[metadata_usc$site == site,]$log_herb_avg)
  points(metadata_usc[metadata_usc$site == site,]$h_apical, metadata_usc[metadata_usc$site == site,]$h_apical.next, col=i)
  ypred <- par_usc[site,'(Intercept)'] + par_usc[site,'h_apical']*xpts + par_usc[site,'log_herb_avg']*meanhe + par_usc[site,'h_apical:log_herb_avg']*xpts*meanhe
  lines(xpts, ypred, col = i)
}
meanhe <- mean(metadata_usc$log_herb_avg)
ypts = pars['(Intercept)'] + pars['h_apical']*xpts + pars['log_herb_avg']*meanhe + pars['h_apical:log_herb_avg']*xpts*meanhe
lines(xpts, ypts, col="black", lwd=2, lty=2)

legend("bottomright", sort(unique(as.character(metadata_usc$site))), col=1:5, pch=1)
```

Now site-specific models.
```{r}
xyplot(h_apical.next ~ h_apical|site, data=metadata_usc, para=par_usc, metadata=metadata_usc, xpts=xpts, panel = function(x,y,metadata,para,xpts) {
  panel.xyplot(x, y)
  isite <- rownames(para)[packet.number()]
  meanhe <- mean(metadata[metadata$site == isite,]$log_herb_avg)
  allha <- metadata[metadata$site == isite,]$h_apical
  allhe <- metadata[metadata$site == isite,]$log_herb_avg
  coeff <- para[packet.number(),]
  ymean <- coeff[,'(Intercept)'] + coeff[,'h_apical']*xpts + coeff[,'log_herb_avg']*meanhe + coeff[,'h_apical:log_herb_avg']*meanhe*xpts
  ypred <- coeff[,'(Intercept)'] + coeff[,'h_apical']*allha + coeff[,'log_herb_avg']*allhe + coeff[,'h_apical:log_herb_avg']*allha*allhe
  panel.lines(xpts, ymean, col = "red")
  panel.xyplot(allha, ypred, col='red')
})
```

Let's add year plots (just use predict function):
```{r, eval=FALSE}
xyplot(h_apical.next ~ h_apical|site, data=metadata_usc, para=ypar_usc, metadata=metadata_usc, xpts=xpts, fit=growth.reg.null, group=year, auto.key = TRUE, subscripts=FALSE, panel = function(x,y,groups=groups,subscripts=subscripts,metadata,para,xpts,fit) {
  panel.xyplot(x, y, groups=groups,subscripts=subscripts)
  site <- rownames(para)[packet.number()]
  cols <- c(4,6,3)
  for (i in 1:3) {
    meanhe <- mean(metadata[(metadata$site == site & metadata$year == dimnames(para)[[3]][i]),]$herb_avg)
    
    # First, explicit function
    coeff <- para[packet.number(),,i]
    ypred <- coeff['(Intercept)'] + coeff['h_apical']*xpts + coeff['herb_avg']*meanhe
    panel.lines(xpts, ypred, col = cols[i])
    
    # Now from fit
    # ypred <- predict(fit, newdata = data.frame(h_apical = (xpts-muha)/sdha, herb_avg = rep((meanhe-muhe)/sdhe, length(xpts)), site = site, year = dimnames(para)[[3]][i]))
    # panel.lines(xpts, ypred, col = cols[i], lty=2)
  }
})
```

Slopes are for some reason looking backwards!  Let's do model validation now.

```{r}
plot(growth.reg.final)
E <- resid(growth.reg.final)
hist(E, xlab = "Residuals", main = "")
plot(metadata_usc$h_apical, E, xlab = "Apical height", ylab = "Residuals")
plot(metadata_usc$log_herb_avg, E, xlab = "Avg. Herbivory Score", ylab = "Residuals")
```

## Pods

```{r}
metadata_usc <- metadata %>% filter(!is.na(h_apical),
                                    !is.na(h_apical.next),
                                    !is.na(herb_avg),
                                    fec.flower == 1,
                                    surv == 1,
                                    !is.na(N_pods),
                                    h_apical.next > 50,
                                    !(site == "YTB" & h_apical <= 50))

metadata_sc <- metadata_usc %>% mutate_each(funs(sc = as.numeric(scale(.))), h_apical, h_apical.next, log_herb_avg)

# Get scaling parameters (really just mean and sd)
h_apical_sc <- scale(metadata_usc$h_apical)
h_apical.next_sc <- scale(metadata_usc$h_apical.next)
log_herb_avg_sc <- scale(metadata_usc$log_herb_avg)

glmerCtrl <- glmerControl(optimizer = c("bobyqa"), optCtrl = list(maxfun=50000))

xyplot(N_pods ~ h_apical.next|site, data=metadata_sc, group=year, auto.key = TRUE)
```

First, do full model.

```{r}
pods.reg.full_sept = glmer(N_pods ~ h_apical.next*log_herb_avg + (h_apical.next*log_herb_avg|site/transect)+(h_apical.next*log_herb_avg|year), data=metadata_sc, nAGQ=1, family=poisson(), control=glmerCtrl)

pods.reg.full_june = glmer(N_pods ~ h_apical*log_herb_avg + (h_apical*log_herb_avg|site/transect)+(h_apical*log_herb_avg|year), data=metadata_sc, nAGQ=1, family=poisson(), control=glmerCtrl)

AIC(pods.reg.full_june, pods.reg.full_sept)
summary(pods.reg.full_sept)
```

We can try and drop h_apical.next:log_herb_avg in the random effect due to small variation.

```{r}
pods.reg.mdl1 = glmer(N_pods ~ h_apical.next*herb_avg + (h_apical.next*log_herb_avg|site/transect)+(h_apical.next+log_herb_avg|year), data=metadata_sc, nAGQ=1, family=poisson(), control=glmerCtrl)

pods.reg.mdl2 = glmer(N_pods ~ h_apical.next*herb_avg + (h_apical.next+log_herb_avg|site/transect)+(h_apical.next+log_herb_avg|year), data=metadata_sc, nAGQ=1, family=poisson(), control=glmerCtrl)

pods.reg.mdl3a = glmer(N_pods ~ h_apical.next*herb_avg + (h_apical.next|site/transect)+(h_apical.next+log_herb_avg|year), data=metadata_sc, nAGQ=1, family=poisson(), control=glmerCtrl)

pods.reg.mdl3b = glmer(N_pods ~ h_apical.next*herb_avg + (h_apical.next+log_herb_avg|site/transect)+(log_herb_avg|year), data=metadata_sc, nAGQ=1, family=poisson(), control=glmerCtrl)

pods.reg.mdl3c = glmer(N_pods ~ h_apical.next*herb_avg + (log_herb_avg|site/transect)+(h_apical.next+log_herb_avg|year), data=metadata_sc, nAGQ=1, family=poisson(), control=glmerCtrl)

AIC(pods.reg.full_sept, pods.reg.mdl1, pods.reg.mdl2, pods.reg.mdl3a, pods.reg.mdl3b, pods.reg.mdl3c)

summary(pods.reg.mdl2)
```

Winner:
```
(h_apical.next+log_herb_avg|site/transect)+(h_apical.next+log_herb_avg|year)
```

```{r}
pods.reg.fmdl1a = glmer(N_pods ~ h_apical.next + log_herb_avg + (h_apical.next+log_herb_avg|site/transect)+(h_apical.next+log_herb_avg|year), data=metadata_sc, nAGQ=1, family=poisson(), control=glmerCtrl)

pods.reg.fmdl1b = glmer(N_pods ~ h_apical.next + h_apical.next:log_herb_avg + (h_apical.next+log_herb_avg|site/transect)+(h_apical.next+log_herb_avg|year), data=metadata_sc, nAGQ=1, family=poisson(), control=glmerCtrl)

pods.reg.fmdl2a = glmer(N_pods ~ h_apical.next + log_herb_avg - 1 + (h_apical.next+log_herb_avg|site/transect)+(h_apical.next+log_herb_avg|year), data=metadata_sc, nAGQ=1, family=poisson(), control=glmerCtrl)

pods.reg.fmdl2b = glmer(N_pods ~ h_apical.next +  (h_apical.next+log_herb_avg|site/transect)+(h_apical.next+log_herb_avg|year), data=metadata_sc, nAGQ=1, family=poisson(), control=glmerCtrl)

pAICtab <- AIC(pods.reg.mdl2, pods.reg.fmdl1a, pods.reg.fmdl1b, pods.reg.fmdl2a, pods.reg.fmdl2b)
pAICtab$dAIC <- pAICtab$AIC-min(pAICtab$AIC)
pAICtab$wAIC <- exp(-0.5*pAICtab$dAIC)
pAICtab$wAIC <- pAICtab$wAIC/sum(pAICtab$wAIC)
(pAICtab <- pAICtab[order(pAICtab$AIC),])

pBICtab <- BIC(pods.reg.mdl2, pods.reg.fmdl1a, pods.reg.fmdl1b, pods.reg.fmdl2a, pods.reg.fmdl2b)
pBICtab$dBIC <- pBICtab$BIC-min(pBICtab$BIC)
pBICtab
```


```{r}
pods.reg.final <- pods.reg.fmdl2a
summary(pods.reg.final)

# Create model class
scaled <- list(h_apical = h_apical_sc, log_herb_avg = log_herb_avg_sc, h_apical.next = h_apical.next_sc)
pods.fit <- mwMod(list(mdl = pods.reg.final, vars = c("h_apical.next", "log_herb_avg"), scaled = scaled))
checkPars(pods.fit) # Check parameters
```

Winner:
```
h_apical.next + log_herb_avg - 1 + (h_apical.next+log_herb_avg|site/transect)+(h_apical.next+log_herb_avg|year)
```
### Check for overdispersion

From [GLMM Wiki](http://glmm.wikidot.com/faq), we grabbed and use the `overdisp_fun` function.

```{r, echo=F}
overdisp_fun <- function(model) {
  ## number of variance parameters in 
  ##   an n-by-n variance-covariance matrix
  vpars <- function(m) {
    nrow(m)*(nrow(m)+1)/2
  }
  model.df <- sum(sapply(VarCorr(model),vpars))+length(fixef(model))
  rdf <- nrow(model.frame(model))-model.df
  rp <- residuals(model,type="pearson")
  Pearson.chisq <- sum(rp^2)
  prat <- Pearson.chisq/rdf
  pval <- pchisq(Pearson.chisq, df=rdf, lower.tail=FALSE)
  c(chisq=Pearson.chisq,ratio=prat,rdf=rdf,p=pval)
}
```

```{r}
overdisp_fun(pods.reg.final)
```

We have a ratio of $1.0073585$ and a "large" $p$-value, so it looks like Poisson is a good fit!

Let's plot full data.

```{r, eval=FALSE}
plot(NULL, axes=T, xlim=c(50,160), ylim=c(0, 15), xlab="", ylab="")
h_apical.next <- attributes(pods.fit$scaled$h_apical.next)$'scaled:center'+attributes(pods.fit$scaled$h_apical.next)$'scaled:scale'*pods.fit$scaled$h_apical.next
log_herb_avg <- attributes(pods.fit$scaled$log_herb_avg)$'scaled:center'+attributes(pods.fit$scaled$log_herb_avg)$'scaled:scale'*pods.fit$scaled$log_herb_avg
xpts <- seq(min(h_apical.next), max(h_apical.next), length.out=100)
for (i in 1:5) {
  isite <- rownames(pods.fit$pars$unscaled)[i]
  I <- pods.fit$mdl@frame$site == isite
  points(h_apical.next[I], pods.fit$mdl@frame$N_pods[I], col=i)
}
for (i in 1:5) {
  isite <- rownames(pods.fit$pars$unscaled)[1+i]
  I <- which(pods.fit$mdl@frame$site == isite)
  meanhe <- mean(log_herb_avg[I])
  ypred <- predict(pods.fit, newdata = list(h_apical.next = xpts, log_herb_avg = meanhe), type=isite)
  lines(xpts, ypred, col = i, lwd=2)
}
meanhe <- mean(log_herb_avg)
ypred <- predict(pods.fit, newdata = list(h_apical.next = xpts, log_herb_avg = meanhe))
lines(xpts, ypred, col="black", lwd=4, lty=2)

legend("topleft", sort(unique(as.character(pods.fit$mdl@frame$site))), col=1:5, pch=1)
```

Now site-specific models.
```{r}
xyplot(N_pods ~ h_apical.next|site, data=metadata_usc, para=par_usc, metadata=metadata_usc, xpts=xpts, panel = function(x,y,metadata,para,xpts) {
  panel.xyplot(x, y)
  isite <- rownames(para)[packet.number()]
  meanhe <- mean(metadata[metadata$site == isite,]$log_herb_avg)
  allha <- metadata[metadata$site == isite,]$h_apical.next
  allhe <- metadata[metadata$site == isite,]$log_herb_avg
  coeff <- para[packet.number(),]
  ymean <- exp(coeff[,'(Intercept)'] + coeff[,'h_apical.next']*xpts + coeff[,'log_herb_avg']*meanhe + coeff[,'h_apical.next:log_herb_avg']*meanhe*xpts)
  ypred <- exp(coeff[,'(Intercept)'] + coeff[,'h_apical.next']*allha + coeff[,'log_herb_avg']*allhe + coeff[,'h_apical.next:log_herb_avg']*allha*allhe)
  panel.lines(xpts, ymean, col = "red")
  panel.xyplot(allha, ypred, col='red')
})
```

# References

 * [Model selection in GLMMs](http://stats.stackexchange.com/questions/74220/generalized-linear-mixed-models-model-selection)
 * [glmmLasso manual](https://cran.r-project.org/web/packages/glmmLasso/glmmLasso.pdf)
 * [Optimizing random effects in GLMMs](https://www.researchgate.net/post/How_can_I_optimize_the_random_effect_structure_in_a_GLMM)
 * [Paper discussing the need to use maximal random effects](http://www.ncbi.nlm.nih.gov/pmc/articles/PMC3881361/)
 * [Bayesian IPMs](http://onlinelibrary.wiley.com/doi/10.1890/15-1526.1/epdf)
 * [Discussion on how to check for overdispersion in GLMM from lme4](https://github.com/lme4/lme4/issues/220)
 * [Heteroscedasticity in lme4](http://r-sig-mixed-models.r-project.narkive.com/qfqOsMAN/r-sig-me-lme4-heteroscedasticity)
 * [Difference between lme4 and nlme](http://stats.stackexchange.com/questions/5344/how-to-choose-nlme-or-lme4-r-library-for-mixed-effects-models)
 * [Specifying multiple random effects in nlme](http://stats.stackexchange.com/questions/58669/specifying-multiple-separate-random-effects-in-lme)
 * [Variance-covariance structure for random effects in glmer](http://stats.stackexchange.com/questions/86958/variance-covariance-structure-for-random-effects-in-glmer)
 * [Displaying model fits in lattice plots](http://lattice.r-forge.r-project.org/Vignettes/src/lattice-tricks/regression-lines.pdf)
 * [Extracting slopes for cases from a mixed effects model (lme4)](http://stats.stackexchange.com/questions/122009/extracting-slopes-for-cases-from-a-mixed-effects-model-lme4)
 * [Taking control of qualitative colors in lattice](http://www.stat.ubc.ca/~jenny/STAT545A/block16_colorsLatticeQualitative.html)
 
# Appendix

## glmmLasso

The next bit is stuff from the function `glmmLasso`, which is another package that does variable selection for GLMMs.  Keeping it for reference (took me a bit to figure out how to use the damn thing).

```{r, eval=FALSE}
gL1 <- glmmLasso(fec.flower ~ h_apical + herb_avg + h_apical:herb_avg, rnd = list(site=~1, year=~1+h_apical), lambda=10, data=metadata_sc, family=binomial(link=logit))
gL2 <- glmmLasso(fec.flower ~ h_apical + herb_avg + h_apical:herb_avg, rnd = list(site=~1+herb_avg, year=~1+h_apical), lambda=10, data=metadata_sc, family=binomial(link=logit))
```

To use it properly, `lambda` needs to be optimized.  Type ` demo("glmmLasso-soccer")` in R to see how this is done (draft code is in the file `glmmFit.R`).

## Growth (individual sites)

Let's look at BLD1 first:

```{r, eval=F}
metaBLD1 <- metadata %>% filter(site == "BLD1",
                                !is.na(h_apical),
                                !is.na(h_apical.next),
                                !is.na(herb_avg),
                                fec.flower == 1,
                                surv == 1)
xyplot(h_apical.next ~ h_apical, data=metaBLD1, group = year, auto.key = TRUE)

growth.reg.null=lmer(h_apical.next~h_apical*herb_avg+(1|year),data=metaBLD1, REML=T)

growth.reg.height=lmer(h_apical.next~h_apical*herb_avg+(h_apical|year),data=metaBLD1, REML=T)

growth.reg.herb=lmer(h_apical.next~h_apical*herb_avg+(herb_avg|year),data=metaBLD1, REML=T)

AIC(growth.reg.null, growth.reg.height, growth.reg.herb)

growth.mdl1.BLD1 <- lm(h_apical.next ~ h_apical*herb_avg, data=metaBLD1)
growth.mdlnoi.BLD1 <- lm(h_apical.next ~ h_apical+herb_avg, data=metaBLD1)
growth.mdlnohe.BLD1 <- lm(h_apical.next ~ h_apical+h_apical:herb_avg, data=metaBLD1)
growth.mdl0.BLD1 <- lm(h_apical.next ~ h_apical, data=metaBLD1)

AIC(growth.mdl1.BLD1, growth.mdlnoi.BLD1, growth.mdlnohe.BLD1, growth.mdl0.BLD1)

par(mfrow=c(2,2))
plot(growth.mdlnohe.BLD1)
par(mfrow=c(1,1))
```

Now BLD2:

```{r, eval=F}
metaBLD2 <- metadata %>% filter(site == "BLD2",
                                fec.flower == 1,
                                !is.na(h_apical),
                                !is.na(h_apical.next),
                                !is.na(herb_avg))
growth.mdl1.BLD2 <- lm(h_apical.next ~ h_apical*herb_avg, data=metaBLD2)
growth.mdlnoi.BLD2 <- lm(h_apical.next ~ h_apical+herb_avg, data=metaBLD2)
growth.mdlnohe.BLD2 <- lm(h_apical.next ~ h_apical+h_apical:herb_avg, data=metaBLD2)
growth.mdl0.BLD2 <- lm(h_apical.next ~ h_apical, data=metaBLD2)

AIC(growth.mdl1.BLD2, growth.mdlnoi.BLD2, growth.mdlnohe.BLD2, growth.mdl0.BLD2)

par(mfrow=c(2,2))
plot(growth.mdlnohe.BLD2)
par(mfrow=c(1,1))
```

Now PWR:

```{r, eval=F}
metaPWR <- metadata %>% filter(site == "PWR",
                                fec.flower == 1,
                                !is.na(h_apical),
                                !is.na(h_apical.next),
                                !is.na(herb_avg))
growth.mdl1.PWR <- lm(h_apical.next ~ h_apical*herb_avg, data=metaPWR)
growth.mdlnoi.PWR <- lm(h_apical.next ~ h_apical+herb_avg, data=metaPWR)
growth.mdlnohe.PWR <- lm(h_apical.next ~ h_apical+h_apical:herb_avg, data=metaPWR)
growth.mdl0.PWR <- lm(h_apical.next ~ h_apical, data=metaPWR)

AIC(growth.mdl1.PWR, growth.mdlnoi.PWR, growth.mdlnohe.PWR, growth.mdl0.PWR)

par(mfrow=c(2,2))
plot(growth.mdlnohe.PWR)
par(mfrow=c(1,1))
```

Now SKY:

```{r, eval=F}
metaSKY <- metadata %>% filter(site == "SKY",
                                fec.flower == 1,
                                !is.na(h_apical),
                                !is.na(h_apical.next),
                                !is.na(herb_avg))
growth.mdl1.SKY <- lm(h_apical.next ~ h_apical*herb_avg, data=metaSKY)
growth.mdlnoi.SKY <- lm(h_apical.next ~ h_apical+herb_avg, data=metaSKY)
growth.mdlnohe.SKY <- lm(h_apical.next ~ h_apical+h_apical:herb_avg, data=metaSKY)
growth.mdl0.SKY <- lm(h_apical.next ~ h_apical, data=metaSKY)

AIC(growth.mdl1.SKY, growth.mdlnoi.SKY, growth.mdlnohe.SKY, growth.mdl0.SKY)

par(mfrow=c(2,2))
plot(growth.mdl1.SKY)
par(mfrow=c(1,1))
```

Now YTB:

```{r, eval=F}
metaYTB <- metadata %>% filter(site == "YTB",
                               fec.flower == 1,
                               surv == 1,
                               h_apical > 50,
                               h_apical.next > 50,
                               !is.na(h_apical),
                               !is.na(h_apical.next),
                               !is.na(herb_avg))

xyplot(h_apical.next ~ h_apical, data=metaYTB, group = year, auto.key = TRUE)

growth.reg.null=lmer(h_apical.next~h_apical*herb_avg+(1|year),data=metaYTB, REML=T)

growth.reg.height=lmer(h_apical.next~h_apical*herb_avg+(h_apical|year),data=metaYTB, REML=T)

AIC(growth.reg.null, growth.reg.height)

growth.mdl1.YTB <- lm(h_apical.next ~ h_apical*herb_avg, data=metaYTB)
growth.mdlnoi.YTB <- lm(h_apical.next ~ h_apical+herb_avg, data=metaYTB)
growth.mdlnohe.YTB <- lm(h_apical.next ~ h_apical+h_apical:herb_avg, data=metaYTB)
growth.mdl0.YTB <- lm(h_apical.next ~ h_apical, data=metaYTB)

AIC(growth.mdl1.YTB, growth.mdlnoi.YTB, growth.mdlnohe.YTB, growth.mdl0.YTB)

par(mfrow=c(2,2))
plot(growth.mdl1.YTB)
par(mfrow=c(1,1))
```
